{
  "selectedFiles": [],
  "selectedURLs": [],
  "selectedNotes": [],
  "selectedSpecials": [
    [
      "selection:1732280598504",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/get-started/tutorial/hello-world"
      }
    ],
    [
      "selection:1732280608852",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/reference/manifest"
      }
    ],
    [
      "selection:1732280623301",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/develop/concepts/service-workers"
      }
    ],
    [
      "selection:1732280645719",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts"
      }
    ],
    [
      "selection:1732280682349",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/reference/api/action"
      }
    ],
    [
      "selection:1732280701383",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/reference/api/sidePanel"
      }
    ],
    [
      "selection:1732280744188",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest"
      }
    ],
    [
      "selection:1732280813065",
      {
        "icon": "✂️",
        "name": "Selected Content from https://developer.chrome.com/docs/extensions/get-started/tutorial/scripts-activetab"
      }
    ]
  ],
  "outputContents": [
    [
      "selection:1732280598504",
      "Selected content from https://developer.chrome.com/docs/extensions/get-started/tutorial/hello-world on 2024-11-22 13:03:18\n\nHello World extension \nbookmark_border\nOn this page\n\nOverview\nHello World\nLoad an unpacked extension\nPin the extension\nReload the extension\n\nLearn the basics of Chrome extension development by building your first Hello World extension.\n\nOverview\nYou will create a \"Hello World\" example, load the extension locally, locate logs, and explore other recommendations.\n\nHello World\nThis extension will display “Hello Extensions” when the user clicks the extension toolbar icon.\n\n\nHello Extension popup\nStart by creating a new directory to store your extension files. If you prefer, you can download the full source code from GitHub.\n\nNext, create a new file in this directory called manifest.json. This JSON file describes the extension's capabilities and configuration. For example, most manifest files contain an \"action\" key which declares the image Chrome should use as the extension's action icon and the HTML page to show in a popup when the extension's action icon is clicked.\n\n\n{\n  \"manifest_version\": 3,\n  \"name\": \"Hello Extensions\",\n  \"description\": \"Base Level Extension\",\n  \"version\": \"1.0\",\n  \"action\": {\n    \"default_popup\": \"hello.html\",\n    \"default_icon\": \"hello_extensions.png\"\n  }\n}\nDownload the icon to your directory, and be sure to change its name to match what's in the \"default_icon\" key.\n\nFor the popup, create a file named hello.html, and add the following code:\n\n\n<html>\n  <body>\n    <h1>Hello Extensions</h1>\n  </body>\n</html>\nThe extension now displays a popup when the extension's action icon (toolbar icon) is clicked. You can test it in Chrome by loading it locally. Ensure all files are saved.\n\nLoad an unpacked extension\nTo load an unpacked extension in developer mode:\n\nGo to the Extensions page by entering chrome://extensions in a new tab. (By design chrome:// URLs are not linkable.)\nAlternatively, click the Extensions menu puzzle button and select Manage Extensions at the bottom of the menu.\nOr, click the Chrome menu, hover over More Tools, then select Extensions.\nEnable Developer Mode by clicking the toggle switch next to Developer mode.\nClick the Load unpacked button and select the extension directory.\n\nExtensions page (chrome://extensions)\nTa-da! The extension has been successfully installed. If no extension icons were included in the manifest, a generic icon will be created for the extension.\n\nPin the extension\nBy default, when you load your extension locally, it will appear in the extensions menu (). Pin your extension to the toolbar to quickly access your extension during development.\n\n\nPinning the extension\nClick the extension's action icon (toolbar icon); you should see a popup.\n\n\nHello World extension\nReload the extension\nGo back to the code and change the name of the extension to \"Hello Extensions of the world!\" in the manifest.\n\n\n{\n  \"manifest_version\": 3,\n  \"name\": \"Hello Extensions of the world!\",\n  ...\n}\nAfter saving the file, to see this change in the browser you also have to refresh the extension. Go to the Extensions page and click the refresh icon next to the on/off toggle:\n\n\n\nWhen to reload the extension\nThe following table shows which components need to be reloaded to see changes:\n\nExtension component\tRequires extension reload\nThe manifest\tYes\nService worker\tYes\nContent scripts\tYes (plus the host page)\nThe popup\tNo\nOptions page\tNo\nOther extension HTML pages\tNo\nFind console logs and errors\nConsole logs\nDuring development, you can debug your code by accessing the browser console logs. In this case, we will locate the logs for the popup. Start by adding a script tag to hello.html.\n\n\n<html>\n  <body>\n    <h1>Hello Extensions</h1>\n    <script src=\"popup.js\"></script>\n  </body>\n</html>\nCreate a popup.js file and add the following code:\n\n\nconsole.log(\"This is a popup!\")\nTo see this message logged in the Console:\n\nOpen the popup.\nRight-click the popup.\nSelect Inspect.\n\nInspecting a popup.\nIn the DevTools, navigate to the Console panel.\n\nInspecting a popup\nError logs\nNow let's break the extension. We can do so by removing the closing quote in popup.js:\n\n\nconsole.log(\"This is a popup!) // ❌ broken code\nGo to the Extensions page and open the popup. An Errors button will appear.\n\n\n\nClick the Errors button to learn more about the error:\n\n\n\nTo learn more about debugging the service worker, options page, and content scripts, see Debugging extensions.\n\nStructure an extension project\nThere are many ways to structure an extension project; however, the only prerequisite is to place the manifest.json file in the extension's root directory as in following example:\n\n\n\nUse TypeScript\nIf you are developing using a code editor such as VSCode or Atom, you can use the npm package chrome-types to take advantage of auto-completion for the Chrome API. This npm package is updated automatically when the Chromium source code changes.\n\nKey point: Update this npm package frequently to work with the latest Chromium version.\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/get-started/tutorial/hello-world"
    ],
    [
      "selection:1732280608852",
      "Selected content from https://developer.chrome.com/docs/extensions/reference/manifest on 2024-11-22 13:03:28\n\nManifest file format \nbookmark_border\nOn this page\nExamples\nManifest keys\nKeys required by the Extensions platform\nKeys required by Chrome Web Store\nOptional keys\nOptional ChromeOS keys\nEvery extension must have a manifest.json file in its root directory that lists important information about the structure and behavior of that extension. This page explains the structure of extension manifests and the features they can include.\n\nExamples\nThe following example manifests show the basic manifest structure and some commonly used features as a starting point for creating your own manifest:\n\nMinimal manifest\nRegister a content script\nSide panel\nMore\n\n{\n  \"manifest_version\": 3,\n  \"name\": \"Minimal Manifest\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A basic example extension with only required keys\",\n  \"icons\": {\n    \"48\": \"images/icon-48.png\",\n    \"128\": \"images/icon-128.png\"\n  },\n}\nManifest keys\nThe following is a list of all supported manifest keys.\n\nKeys required by the Extensions platform\n\"manifest_version\"\nAn integer specifying the version of the manifest file format that your extension uses. The only supported value is 3.\n\"name\"\nA string that identifies the extension in the Chrome Web Store, the install dialog, and the user's Chrome Extensions page (chrome://extensions). The maximum length is 75 characters. For information on using locale-specific names, see Internationalization.\n\"version\"\nA string that identifies the extension's version number. For information on version number formatting, see Version.\nKeys required by Chrome Web Store\n\"description\"\nA string that describes the extension on both the Chrome Web Store and the user's extension management page. The maximum length is 132 characters. For information on localizing descriptions, see Internationalization.\n\"icons\"\nOne or more icons that represent your extension. For information about best practices, see Icons.\nOptional keys\n\"action\"\nDefines the appearance and behavior of the extension's icon in the Google Toolbar. For more information, see chrome.action.\n\"author\"\nSpecifies the email address of the account that was used to create the extension.\n\"background\"\nSpecifies the JavaScript file containing the extension's service worker, which acts as an event handler. For more information, see About extension service workers.\n\"chrome_settings_overrides\"\nDefines overrides for selected Chrome settings. For more information, see Overriding Chrome settings.\n\"chrome_url_overrides\"\nDefines overrides for default Chrome pages. For more information, see Override Chrome pages.\n\"commands\"\nDefines keyboard shortcuts within the extension. For more information, see chrome.commands.\n\"content_scripts\"\nSpecifies JavaScript or CSS files to be used when the user opens certain web pages. For more information, see Content scripts.\n\"content_security_policy\"\nDefines restrictions on the scripts, styles, and other resources an extension can use. For more information, see Content security policy.\n\"cross_origin_embedder_policy\"\nSpecifies a value for the Cross-Origin-Embedder-Policy HTTP header, which configures embedding of cross-origin resources in an extension page.\n\"cross_origin_opener_policy\"\nSpecifies a value for the Cross-Origin-Opener-Policy HTTP header, which lets you ensure that a top-level extension page doesn't share a browsing context group with cross-origin documents.\n\"declarative_net_request\"\nDefines static rules for the declarativeNetRequest API, which allows blocking and modifying of network requests.\n\"default_locale\"\nA string that defines the default language of an extension that supports multiple locales. Examples include \"en\" and \"pt_BR\". This key is required in localized extensions, and must not be used in extensions that aren't localized. For more information, see Internationalization.\n\"devtools_page\"\nDefines pages that use the DevTools APIs.\n\"export\"\nAllows resources to be exported from the extension. For more information, see Export.\n\"externally_connectable\"\nSpecifies what other pages and extensions can connect to your extensions. For more information, see \"externally_connectable\".\n\"homepage_url\"\nA string specifying a URL for the extension's homepage. If this is undefined, the homepage defaults to the extension's Chrome Web Store page. This field is particularly useful if you host the extension on your own site.\n\"host_permissions\"\nLists the web pages your extension is allowed to interact with, defined using URL match patterns. User permission for these sites is requested at install time. For more information, see Host permissions.\n\"import\"\nAllows resources to be imported into the extension. For more information, see Import.\n\"incognito\"\nDefines how the extension behaves in incognito mode. Supported values are \"spanning\", \"split\", and \"not_allowed\". For more information, see Incognito.\n\"key\"\nSpecifies your extension's ID for various development use cases. For more information, see Key.\n\"minimum_chrome_version\"\nDefines the oldest Chrome version that can install your extension. The value must be a substring of an existing Chrome browser version string, such as \"107\" or \"107.0.5304.87\". Users with versions of Chrome older than the minimum version see a \"Not compatible\" warning in the Chrome Web Store, and are unable to install your extension. If you add this to an existing extension, users whose Chrome version is older won't receive automatic updates to your extension. This includes business users in ephemeral mode.\n\"oauth2\"\nAllows the use of an OAuth 2.0 security ID. The value of this key must be an object with \"client_id\" and \"scopes\" properties. For details, see the OAuth 2.0 tutorial.\n\"omnibox\"\nAllows the extension to register a keyword in Chrome's address bar. For more information, see Omnibox.\n\"optional_host_permissions\"\nDeclares optional host permissions for your extension.\n\"optional_permissions\"\nDeclares optional permissions for your extension.\n\"options_page\"\nSpecifies a path to an options.html file for the extension to use as an options page. For more information, see Give users options.\n\"options_ui\"\nSpecifies a path to an HTML file that lets a user change extension options from the Chrome Extensions page. For more information, see Embedded options.\n\"permissions\"\nEnables use of particular extension APIs. See Permissions for a general explanation. Reference pages for individual APIs list the permissions they require.\n\"requirements\"\nLists technologies required to use the extension. For a list of supported requirements, see Requirements.\n\"sandbox\"\nDefines a set of extension pages that don't have access to extension APIs or direct access to non-sandboxed pages. For more information, see Sandbox.\n\"short_name\"\nA string containing a shortened version of the extension's name to be used when character space is limited. The maximum length is 12 characters. If this is undefined, a truncated version of the \"name\" key displays instead.\n\"side_panel\"\nIdentifies an HTML file to display in a sidePanel.\n\"storage\"\nDeclares a JSON schema for the managed storage area. For more information, see Manifest for storage areas.\n\"tts_engine\"\nRegisters the extension as a text to speech engine. For more information, see the ttsEngine API.\n\"update_url\"\nA string containing the URL of the extension's updates page. Use this key if you're hosting your extension outside the Chrome Web Store.\n\"version_name\"\nA string describing the extension's version. Examples include \"1.0 beta\" and \"build rc2\". If this is unspecified, the \"version\" value displays on the extension management page instead.\n\"web_accessible_resources\"\nDefines files within the extension that can be accessed by web pages or other extensions. For more information, see Web Accessible Resources.\nOptional ChromeOS keys\n\"file_browser_handlers\"\nProvides access to the fileBrowserHandler API, which lets extensions access the ChromeOS file browser.\n\"file_handlers\"\nSpecifies file types for ChromeOS extensions to handle. For more information, see file_handlers.\n\"file_system_provider_capabilities\"\nAllows access to the fileSystemProvider API, which lets extensions create file systems that ChromeOS can use.\n\"input_components\"\nAllows the use of the Input Method Editor API. For more information, see input_components.\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/reference/manifest"
    ],
    [
      "selection:1732280623301",
      "Selected content from https://developer.chrome.com/docs/extensions/develop/concepts/service-workers on 2024-11-22 13:03:43\n\nAbout extension service workers \nbookmark_border\nThis section explains what you need to know to use service workers in extensions. You should read this section whether you're familiar with service workers or not. Extension service workers are an extension's central event handler. That makes them just different enough from web service workers that the mountains of service worker articles around the web may or may not be useful.\n\nExtension service workers have a few things in common with their web counterparts. An extension service worker is loaded when it is needed, and unloaded when it goes dormant. Once loaded, an extension service worker generally runs as long as it is actively receiving events, though it can shut down. Like its web counterpart, an extension service worker cannot access the DOM, though you can use it if needed with offscreen documents.\n\nExtension service workers are more than network proxies (as web service workers are often described). In addition to the standard service worker events, they also respond to extension events such as navigating to a new page, clicking a notification, or closing a tab. They're also registered and updated differently from web service workers.\n\nNote: In some contexts here and around the web you will see service workers called \"background scripts\". Previously, this site often used the terms interchangeably. Manifest V2 also included a feature called a background script. To avoid overloading the term and creating confusion, this section will use \"extension service worker\" or \"service worker\" throughout.\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/develop/concepts/service-workers"
    ],
    [
      "selection:1732280645719",
      "Selected content from https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts on 2024-11-22 13:04:05\n\nContent scripts \nbookmark_border\nOn this page\n\nUnderstand content script capabilities\nWork in isolated worlds\nInject scripts\nInject with static declarations\nInject with dynamic declarations\nInject programmatically\nExclude matches and globs\nRun time\n\nContent scripts are files that run in the context of web pages. Using the standard Document Object Model (DOM), they are able to read details of the web pages the browser visits, make changes to them, and pass information to their parent extension.\n\nUnderstand content script capabilities\nContent scripts can access the following extension APIs directly:\n\ndom\ni18n\nstorage\nruntime.connect()\nruntime.getManifest()\nruntime.getURL()\nruntime.id\nruntime.onConnect\nruntime.onMessage\nruntime.sendMessage()\nContent scripts are unable to access other APIs directly. But they can access them indirectly by exchanging messages with other parts of your extension.\n\nYou can also access other files in your extension from a content script, using APIs like fetch(). To do this, you need to declare them as web-accessible resources. Note that this also exposes the resources to any first-party or third-party scripts running on the same site.\n\nWork in isolated worlds\nContent scripts live in an isolated world, allowing a content script to make changes to its JavaScript environment without conflicting with the page or other extensions' content scripts.\n\nKey term: An isolated world is a private execution environment that isn't accessible to the page or other extensions. A practical consequence of this isolation is that JavaScript variables in an extension's content scripts are not visible to the host page or other extensions' content scripts. The concept was originally introduced with the initial launch of Chrome, providing isolation for browser tabs.\nAn extension may run in a web page with code similar to the following example.\n\nwebPage.html\n\n\n<html>\n  <button id=\"mybutton\">click me</button>\n  <script>\n    var greeting = \"hello, \";\n    var button = document.getElementById(\"mybutton\");\n    button.person_name = \"Bob\";\n    button.addEventListener(\n        \"click\", () => alert(greeting + button.person_name + \".\"), false);\n  </script>\n</html>\nThat extension could inject the following content script using one of the techniques outlined in the Inject scripts section.\n\ncontent-script.js\n\n\nvar greeting = \"hola, \";\nvar button = document.getElementById(\"mybutton\");\nbutton.person_name = \"Roberto\";\nbutton.addEventListener(\n    \"click\", () => alert(greeting + button.person_name + \".\"), false);\nWith this change, both alerts appear in sequence when the button is clicked.\n\nNote: Not only does each extension run in its own isolated world, but content scripts and the web page do too. This means that none of these (web page, content scripts, and any running extensions) can access the context and variables of the others.\nInject scripts\nContent scripts can be declared statically, declared dynamically, or programmatically injected.\n\nInject with static declarations\nUse static content script declarations in manifest.json for scripts that should be automatically run on a well known set of pages.\n\nStatically declared scripts are registered in the manifest under the \"content_scripts\" key. They can include JavaScript files, CSS files, or both. All auto-run content scripts must specify match patterns.\n\nmanifest.json\n\n\n{\n \"name\": \"My extension\",\n ...\n \"content_scripts\": [\n   {\n     \"matches\": [\"https://*.nytimes.com/*\"],\n     \"css\": [\"my-styles.css\"],\n     \"js\": [\"content-script.js\"]\n   }\n ],\n ...\n}\n\nName\tType\tDescription\nmatches\tarray of strings\tRequired. Specifies which pages this content script will be injected into. See Match Patterns for details on the syntax of these strings and Match patterns and globs for information on how to exclude URLs.\ncss\tarray of strings\tOptional. The list of CSS files to be injected into matching pages. These are injected in the order they appear in this array, before any DOM is constructed or displayed for the page.\njs\tarray of strings\tOptional. The list of JavaScript files to be injected into matching pages. Files are injected in the order they appear in this array. Each string in this list must contain a relative path to a resource in the extension's root directory. Leading slashes (`/`) are automatically trimmed.\nrun_at\tRunAt\tOptional. Specifies when the script should be injected into the page. Defaults to document_idle.\nmatch_about_blank\tboolean\tOptional. Whether the script should inject into an about:blank frame where the parent or opener frame matches one of the patterns declared in matches. Defaults to false.\nmatch_origin_as_fallback\tboolean\tOptional. Whether the script should inject in frames that were created by a matching origin, but whose URL or origin may not directly match the pattern. These include frames with different schemes, such as about:, data:, blob:, and filesystem:. See also Injecting in related frames.\nworld\tExecutionWorld\tOptional. The JavaScript world for a script to execute within. Defaults to ISOLATED. See also Work in isolated worlds.\nInject with dynamic declarations\nDynamic content scripts are useful when the match patterns for content scripts are not well known or when content scripts shouldn't always be injected on known hosts.\n\nIntroduced in Chrome 96, dynamic declarations are similar to static declarations, but the content script object is registered with Chrome using methods in the chrome.scripting namespace rather than in manifest.json. The Scripting API also allows extension developers to:\n\nRegister content scripts.\nGet a list of registered content scripts.\nUpdate the list of registered content scripts.\nRemove registered content scripts.\nLike static declarations, dynamic declarations can include JavaScript files, CSS files, or both.\n\nservice-worker.js\n\n\nchrome.scripting\n  .registerContentScripts([{\n    id: \"session-script\",\n    js: [\"content.js\"],\n    persistAcrossSessions: false,\n    matches: [\"*://example.com/*\"],\n    runAt: \"document_start\",\n  }])\n  .then(() => console.log(\"registration complete\"))\n  .catch((err) => console.warn(\"unexpected error\", err))\nservice-worker.js\n\n\nchrome.scripting\n  .updateContentScripts([{\n    id: \"session-script\",\n    excludeMatches: [\"*://admin.example.com/*\"],\n  }])\n  .then(() => console.log(\"registration updated\"));\nservice-worker.js\n\n\nchrome.scripting\n  .getRegisteredContentScripts()\n  .then(scripts => console.log(\"registered content scripts\", scripts));\nservice-worker.js\n\n\nchrome.scripting\n  .unregisterContentScripts({ ids: [\"session-script\"] })\n  .then(() => console.log(\"un-registration complete\"));\nInject programmatically\nUse programmatic injection for content scripts that need to run in response to events or on specific occasions.\n\nTo inject a content script programmatically, your extension needs host permissions for the page it's trying to inject scripts into. Host permissions can either be granted by requesting them as part of your extension's manifest or temporarily using \"activeTab\".\n\nThe following is a different versions of an activeTab-based extension.\n\nmanifest.json:\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"permissions\": [\n    \"activeTab\",\n    \"scripting\"\n  ],\n  \"background\": {\n    \"service_worker\": \"background.js\"\n  },\n  \"action\": {\n    \"default_title\": \"Action Button\"\n  }\n}\nContent scripts can be injected as files.\n\ncontent-script.js\n\n\n\ndocument.body.style.backgroundColor = \"orange\";\nservice-worker.js:\n\n\nchrome.action.onClicked.addListener((tab) => {\n  chrome.scripting.executeScript({\n    target: { tabId: tab.id },\n    files: [\"content-script.js\"]\n  });\n});\nOr, a function body can be injected and executed as a content script.\n\nservice-worker.js:\n\n\nfunction injectedFunction() {\n  document.body.style.backgroundColor = \"orange\";\n}\n\nchrome.action.onClicked.addListener((tab) => {\n  chrome.scripting.executeScript({\n    target : {tabId : tab.id},\n    func : injectedFunction,\n  });\n});\nBe aware that the injected function is a copy of the function referenced in the chrome.scripting.executeScript() call, not the original function itself. As a result, the function's body must be self contained; references to variables outside of the function will cause the content script to throw a ReferenceError.\n\nWhen injecting as a function, you can also pass arguments to the function.\n\nservice-worker.js\n\n\nfunction injectedFunction(color) {\n  document.body.style.backgroundColor = color;\n}\n\nchrome.action.onClicked.addListener((tab) => {\n  chrome.scripting.executeScript({\n    target : {tabId : tab.id},\n    func : injectedFunction,\n    args : [ \"orange\" ],\n  });\n});\nExclude matches and globs\nTo customize specified page matching, include the following fields in a declarative registration.\n\nName\tType\tDescription\nexclude_matches\tarray of strings\tOptional. Excludes pages that this content script would otherwise be injected into. See Match Patterns for details of the syntax of these strings.\ninclude_globs\tarray of strings\tOptional. Applied after matches to include only those URLs that also match this glob. This is intended to emulate the @include Greasemonkey keyword.\nexclude_globs\tarray of string\tOptional. Applied after matches to exclude URLs that match this glob. Intended to emulate the @exclude Greasemonkey keyword.\nThe content script will be injected into a page if both of the following are true:\n\nIts URL matches any matches pattern and any include_globs pattern.\nThe URL doesn't also match an exclude_matches or exclude_globs pattern. Because the matches property is required, exclude_matches, include_globs, and exclude_globs can only be used to limit which pages will be affected.\nThe following extension injects the content script into https://www.nytimes.com/health but not into https://www.nytimes.com/business .\n\nmanifest.json\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://*.nytimes.com/*\"],\n      \"exclude_matches\": [\"*://*/*business*\"],\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}\nservice-worker.js\n\n\nchrome.scripting.registerContentScripts([{\n  id : \"test\",\n  matches : [ \"https://*.nytimes.com/*\" ],\n  excludeMatches : [ \"*://*/*business*\" ],\n  js : [ \"contentScript.js\" ],\n}]);\nGlob properties follow a different, more flexible syntax than match patterns. Acceptable glob strings are URLs that may contain \"wildcard\" asterisks and question marks. The asterisk (*) matches any string of any length, including the empty string, while the question mark (?) matches any single character.\n\nFor example, the glob https://???.example.com/foo/\\* matches any of the following:\n\nhttps://www.example.com/foo/bar\nhttps://the.example.com/foo/\nHowever, it does not match the following:\n\nhttps://my.example.com/foo/bar\nhttps://example.com/foo/\nhttps://www.example.com/foo\nThis extension injects the content script into https://www.nytimes.com/arts/index.html and https://www.nytimes.com/jobs/index.htm*, but not into https://www.nytimes.com/sports/index.html:\n\nmanifest.json\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://*.nytimes.com/*\"],\n      \"include_globs\": [\"*nytimes.com/???s/*\"],\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}\nThis extension injects the content script into https://history.nytimes.com and https://.nytimes.com/history, but not into https://science.nytimes.com or https://www.nytimes.com/science:\n\nmanifest.json\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://*.nytimes.com/*\"],\n      \"exclude_globs\": [\"*science*\"],\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}\nOne, all, or some of these can be included to achieve the correct scope.\n\nmanifest.json\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://*.nytimes.com/*\"],\n      \"exclude_matches\": [\"*://*/*business*\"],\n      \"include_globs\": [\"*nytimes.com/???s/*\"],\n      \"exclude_globs\": [\"*science*\"],\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}\nRun time\nThe run_at field controls when JavaScript files are injected into the web page. The preferred and default value is \"document_idle\". See the RunAt type for other possible values.\n\nmanifest.json\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://*.nytimes.com/*\"],\n      \"run_at\": \"document_idle\",\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}\nservice-worker.js\n\n\nchrome.scripting.registerContentScripts([{\n  id : \"test\",\n  matches : [ \"https://*.nytimes.com/*\" ],\n  runAt : \"document_idle\",\n  js : [ \"contentScript.js\" ],\n}]);\nName\tType\tDescription\ndocument_idle\tstring\tPreferred. Use \"document_idle\" whenever possible.\n\nThe browser chooses a time to inject scripts between \"document_end\" and immediately after the window.onload event fires. The exact moment of injection depends on how complex the document is and how long it is taking to load, and is optimized for page load speed.\n\nContent scripts running at \"document_idle\" don't need to listen for the window.onload event, they are guaranteed to run after the DOM is complete. If a script definitely needs to run after window.onload, the extension can check if onload has already fired by using the document.readyState property.\ndocument_start\tstring\tScripts are injected after any files from css, but before any other DOM is constructed or any other script is run.\ndocument_end\tstring\tScripts are injected immediately after the DOM is complete, but before subresources like images and frames have loaded.\nSpecify frames\nThe \"all_frames\" field allows the extension to specify if JavaScript and CSS files should be injected into all frames matching the specified URL requirements or only into the topmost frame in a tab.\n\nmanifest.json\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://*.nytimes.com/*\"],\n      \"all_frames\": true,\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}\nservice-worker.js\n\n\nchrome.scripting.registerContentScripts([{\n  id: \"test\",\n  matches : [ \"https://*.nytimes.com/*\" ],\n  allFrames : true,\n  js : [ \"contentScript.js\" ],\n}]);\nName\tType\tDescription\nall_frames\tboolean\tOptional. Defaults to false, meaning that only the top frame is matched.\n\nIf true is specified, all frames will be injected into, even if the frame is not the topmost frame in the tab. Each frame is checked independently for URL requirements. It won't inject into child frames if the URL requirements are not met.\nInject in to related frames\nExtensions may want to run scripts in frames that are related to a matching frame, but don't themselves match. A common scenario when this is the case is for frames with URLs that were created by a matching frame, but whose URLs don't themselves match the script's specified patterns.\n\nThis is the case when an extension wants to inject in frames with URLs that have about:, data:, blob:, and filesystem: schemes. In these cases, the URL won't match the content script's pattern (and, in the case of about: and data:, don't even include the parent URL or origin in the URL at all, as in about:blank or data:text/html,<html>Hello, World!</html>). However, these frames can still be associated with the creating frame.\n\nTo inject into these frames, extensions can specify the \"match_origin_as_fallback\" property on a content script specification in the manifest.\n\nmanifest.json\n\n\n{\n  \"name\": \"My extension\",\n  ...\n  \"content_scripts\": [\n    {\n      \"matches\": [\"https://*.google.com/*\"],\n      \"match_origin_as_fallback\": true,\n      \"js\": [\"contentScript.js\"]\n    }\n  ],\n  ...\n}\nWhen specified and set to true, Chrome will look at the origin of the initiator of the frame to determine whether the frame matches, rather than at the URL of the frame itself. Note that this might also be different than the target frame's origin (e.g., data: URLs have a null origin).\n\nThe initiator of the frame is the frame that created or navigated the target frame. While this is commonly the direct parent or opener, it may not be (as in the case of a frame navigating an iframe within an iframe).\n\nBecause this compares the origin of the initiator frame, the initiator frame could be on at any path from that origin. To make this implication clear, Chrome requires any content scripts specified with \"match_origin_as_fallback\" set to true to also specify a path of *.\n\nWhen both \"match_origin_as_fallback\" and \"match_about_blank\" are specified, \"match_origin_as_fallback\" takes priority.\n\nCommunication with the embedding page\nAlthough the execution environments of content scripts and the pages that host them are isolated from each other, they share access to the page's DOM. If the page wishes to communicate with the content script, or with the extension through the content script, it must do so through the shared DOM.\n\nAn example can be accomplished using window.postMessage():\n\ncontent-script.js\n\n\nvar port = chrome.runtime.connect();\n\nwindow.addEventListener(\"message\", (event) => {\n  // We only accept messages from ourselves\n  if (event.source !== window) {\n    return;\n  }\n\n  if (event.data.type && (event.data.type === \"FROM_PAGE\")) {\n    console.log(\"Content script received: \" + event.data.text);\n    port.postMessage(event.data.text);\n  }\n}, false);\nexample.js\n\n\ndocument.getElementById(\"theButton\").addEventListener(\"click\", () => {\n  window.postMessage(\n      {type : \"FROM_PAGE\", text : \"Hello from the webpage!\"}, \"*\");\n}, false);\nThe non-extension page, example.html, posts messages to itself. This message is intercepted and inspected by the content script and then posted to the extension process. In this way, the page establishes a line of communication to the extension process. The reverse is possible through similar means.\n\nAccess extension files\nTo access an extension file from a content script, you can call chrome.runtime.getURL() to get the absolute URL of your extension asset as shown in the following example (content.js):\n\ncontent-script.js\n\n\nlet image = chrome.runtime.getURL(\"images/my_image.png\")\nTo use fonts or images in a CSS file, you can use @@extension_id to construct a URL as shown in the following example (content.css):\n\ncontent.css\n\n\nbody {\n background-image:url('chrome-extension://__MSG_@@extension_id__/background.png');\n}\n\n@font-face {\n font-family: 'Stint Ultra Expanded';\n font-style: normal;\n font-weight: 400;\n src: url('chrome-extension://__MSG_@@extension_id__/fonts/Stint Ultra Expanded.woff') format('woff');\n}\nAll assets must be declared as web accessible resources in the manifest.json file:\n\nmanifest.json\n\n\n{\n ...\n \"web_accessible_resources\": [\n   {\n     \"resources\": [ \"images/*.png\" ],\n     \"matches\": [ \"https://example.com/*\" ]\n   },\n   {\n     \"resources\": [ \"fonts/*.woff\" ],\n     \"matches\": [ \"https://example.com/*\" ]\n   }\n ],\n ...\n}\nStay secure\nWhile isolated worlds provide a layer of protection, using content scripts can create vulnerabilities in an extension and the web page. If the content script receives content from a separate website, such as by calling fetch(), be careful to filter content against cross-site scripting attacks before injecting it. Only communicate over HTTPS in order to avoid \"man-in-the-middle\" attacks.\n\nBe sure to filter for malicious web pages. For example, the following patterns are dangerous, and disallowed in Manifest V3:\n\nDon't\ncontent-script.js\n\n\nconst data = document.getElementById(\"json-data\");\n// WARNING! Might be evaluating an evil script!\nconst parsed = eval(\"(\" + data + \")\");\nDon't\ncontent-script.js\n\n\nconst elmt_id = ...\n// WARNING! elmt_id might be '); ... evil script ... //'!\nwindow.setTimeout(\"animate(\" + elmt_id + \")\", 200);\nInstead, prefer safer APIs that don't run scripts:\n\nDo\ncontent-script.js\n\n\nconst data = document.getElementById(\"json-data\")\n// JSON.parse does not evaluate the attacker's scripts.\nconst parsed = JSON.parse(data);\nDo\ncontent-script.js\n\n\nconst elmt_id = ...\n// The closure form of setTimeout does not evaluate scripts.\nwindow.setTimeout(() => animate(elmt_id), 200);\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts"
    ],
    [
      "selection:1732280682349",
      "Selected content from https://developer.chrome.com/docs/extensions/reference/api/action on 2024-11-22 13:04:42\n\nchrome.action \nbookmark_border\nOn this page\n\nDescription\nAvailability\nManifest\nConcepts and usage\nParts of the UI\n\nUse the chrome.action API to control the extension's icon in the Google Chrome toolbar.\n\nThe action icons are displayed in the browser toolbar next to the omnibox. After installation, these appear in the extensions menu (the puzzle piece icon). Users can pin your extension icon to the toolbar.\nAvailability\nChrome 88+ MV3+\nManifest\nThe following keys must be declared in the manifest to use this API.\n\n\"action\"\nTo use the chrome.action API, specify a \"manifest_version\" of 3 and include the \"action\" key in your manifest file.\n\nNote: Every extension has an icon in the Chrome toolbar, even if the \"action\" key isn't added to the manifest.\n\n{\n  \"name\": \"Action Extension\",\n  ...\n  \"action\": {\n    \"default_icon\": {              // optional\n      \"16\": \"images/icon16.png\",   // optional\n      \"24\": \"images/icon24.png\",   // optional\n      \"32\": \"images/icon32.png\"    // optional\n    },\n    \"default_title\": \"Click Me\",   // optional, shown in tooltip\n    \"default_popup\": \"popup.html\"  // optional\n  },\n  ...\n}\nThe \"action\" key (along with its children) is optional. When it isn't included, your extension is still shown in the toolbar to provide access to the extension's menu. For this reason, we recommend that you always include at least the \"action\" and \"default_icon\" keys.\n\nConcepts and usage\nParts of the UI\nIcon\nThe icon is the main image on the toolbar for your extension, and is set by the \"default_icon\" key in your manifest's \"action\" key. Icons must be 16 device-independent pixels (DIPs) wide and tall.\n\nThe \"default_icon\" key is a dictionary of sizes to image paths. Chrome uses these icons to choose which image scale to use. If an exact match is not found, Chrome selects the closest available and scales it to fit the image, which might affect image quality.\n\nBecause devices with less-common scale factors like 1.5x or 1.2x are becoming more common, we encourage you to provide multiple sizes for your icons. This also futureproofs your extension against potential icon display size changes. However, if only providing a single size, the \"default_icon\" key can also be set to a string with the path to a single icon instead of a dictionary.\n\nYou can also call action.setIcon() to set your extension's icon programmatically by specifying a different image path or providing a dynamically-generated icon using the HTML canvas element, or, if setting from an extension service worker, the offscreen canvas API.\n\n\nconst canvas = new OffscreenCanvas(16, 16);\nconst context = canvas.getContext('2d');\ncontext.clearRect(0, 0, 16, 16);\ncontext.fillStyle = '#00FF00';  // Green\ncontext.fillRect(0, 0, 16, 16);\nconst imageData = context.getImageData(0, 0, 16, 16);\nchrome.action.setIcon({imageData: imageData}, () => { /* ... */ });\nNote: The action.setIcon() API is intended to set a static image. Don't use animated images for your icons.\nFor packed extensions (installed from a .crx file), images can be in most formats that the Blink rendering engine can display, including PNG, JPEG, BMP, ICO, and others. SVG isn't supported. Unpacked extensions must use PNG images.\n\nTooltip (title)\nThe tooltip, or title, appears when the user holds their mouse pointer over the extension's icon in the toolbar. It's also included in the accessible text spoken by screen readers when the button gets focus.\n\nThe default tooltip is set using the \"default_title\" field of the \"action\" key in manifest.json. You can also set it programmatically by calling action.setTitle().\n\nBadge\nActions can optionally display a \"badge\" — a bit of text layered over the icon. This lets you update the action to display a small amount of information about the state of the extension, such as a counter. The badge has a text component and a background color. Because space is limited, we recommend that badge text use four or fewer characters.\n\nTo create a badge, set it programmatically by calling action.setBadgeBackgroundColor() and action.setBadgeText(). There isn't a default badge setting in the manifest. Badge color values can be either an array of four integers between 0 and 255 that make up the RGBA color of the badge or a string with a CSS color value.\n\n\nchrome.action.setBadgeBackgroundColor(\n  {color: [0, 255, 0, 0]},  // Green\n  () => { /* ... */ },\n);\n\nchrome.action.setBadgeBackgroundColor(\n  {color: '#00FF00'},  // Also green\n  () => { /* ... */ },\n);\n\nchrome.action.setBadgeBackgroundColor(\n  {color: 'green'},  // Also, also green\n  () => { /* ... */ },\n);\nPopup\nAn action's popup is shown when the user clicks on the extension's action button in the toolbar. The popup can contain any HTML contents you like, and will be automatically sized to fit its contents. The popup's size must be between 25x25 and 800x600 pixels.\n\nThe popup is initially set by the \"default_popup\" property in the \"action\" key in the manifest.json file. If present, this property should point to a relative path within the extension directory. It can also be updated dynamically to point to a different relative path using the action.setPopup() method.\n\nNote: The action.onClicked event won't be sent if the extension action has specified a popup to show on click of the current tab.\nUse cases\nPer-tab state\nExtension actions can have different states for each tab. To set a value for an individual tab, use the tabId property in the action API's setting methods. For example, to set the badge text for a specific tab, do something like the following:\n\n\nfunction getTabId() { /* ... */}\nfunction getTabBadge() { /* ... */}\n\nchrome.action.setBadgeText(\n  {\n    text: getTabBadge(tabId),\n    tabId: getTabId(),\n  },\n  () => { ... }\n);\nIf the tabId property is left out, the setting is treated as a global setting. Tab-specific settings take priority over global settings.\n\nEnabled state\nBy default, toolbar actions are enabled (clickable) on every tab. You can control this using the action.enable() and action.disable() methods. This only affects whether the popup (if any) or action.onClicked event is sent to your extension; it doesn't affect the action's presence in the toolbar.\n\nExamples\nThe following examples show some common ways that actions are used in extensions. To try this API, install the Action API example from the chrome-extension-samples repository.\n\nShow a popup\nIt's common for an extension to display a popup when the user clicks the extension's action. To implement this in your own extension, declare the popup in your manifest.json and specify the content that Chrome should display in the popup.\n\n\n// manifest.json\n{\n  \"name\": \"Action popup demo\",\n  \"version\": \"1.0\",\n  \"manifest_version\": 3,\n  \"action\": {\n    \"default_title\": \"Click to view a popup\",\n    \"default_popup\": \"popup.html\"\n  }\n}\n\n<!-- popup.html -->\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    html {\n      min-height: 5em;\n      min-width: 10em;\n      background: salmon;\n    }\n  </style>\n</head>\n<body>\n  <p>Hello, world!</p>\n</body>\n</html>\nInject a content script on click\nA common pattern for extensions is to expose their primary feature using the extension's action. The following example demonstrates this pattern. When the user clicks the action, the extension injects a content script into the current page. The content script then displays an alert to verify that everything worked as expected.\n\n\n// manifest.json\n{\n  \"name\": \"Action script injection demo\",\n  \"version\": \"1.0\",\n  \"manifest_version\": 3,\n  \"action\": {\n    \"default_title\": \"Click to show an alert\"\n  },\n  \"permissions\": [\"activeTab\", \"scripting\"],\n  \"background\": {\n    \"service_worker\": \"background.js\"\n  }\n}\n\n// background.js\nchrome.action.onClicked.addListener((tab) => {\n  chrome.scripting.executeScript({\n    target: {tabId: tab.id},\n    files: ['content.js']\n  });\n});\n\n// content.js\nalert('Hello, world!');\nEmulate actions with declarativeContent\nThis example shows how an extension's background logic can (a) disable an action by default and (b) use declarativeContent to enable the action on specific sites.\n\n\n// service-worker.js\n\n// Wrap in an onInstalled callback to avoid unnecessary work\n// every time the service worker is run\nchrome.runtime.onInstalled.addListener(() => {\n  // Page actions are disabled by default and enabled on select tabs\n  chrome.action.disable();\n\n  // Clear all rules to ensure only our expected rules are set\n  chrome.declarativeContent.onPageChanged.removeRules(undefined, () => {\n    // Declare a rule to enable the action on example.com pages\n    let exampleRule = {\n      conditions: [\n        new chrome.declarativeContent.PageStateMatcher({\n          pageUrl: {hostSuffix: '.example.com'},\n        })\n      ],\n      actions: [new chrome.declarativeContent.ShowAction()],\n    };\n\n    // Finally, apply our new array of rules\n    let rules = [exampleRule];\n    chrome.declarativeContent.onPageChanged.addRules(rules);\n  });\n});\nTypes\nOpenPopupOptions\nChrome 99+\nPROPERTIES\nwindowId\nnumber optional\n\nThe ID of the window to open the action popup in. Defaults to the currently-active window if unspecified.\n\nTabDetails\nPROPERTIES\ntabId\nnumber optional\n\nThe ID of the tab to query state for. If no tab is specified, the non-tab-specific state is returned.\n\nUserSettings\nChrome 91+\nThe collection of user-specified settings relating to an extension's action.\n\nPROPERTIES\nisOnToolbar\nboolean\n\nWhether the extension's action icon is visible on browser windows' top-level toolbar (i.e., whether the extension has been 'pinned' by the user).\n\nUserSettingsChange\nChrome 130+\nPROPERTIES\nisOnToolbar\nboolean optional\n\nWhether the extension's action icon is visible on browser windows' top-level toolbar (i.e., whether the extension has been 'pinned' by the user).\n\nMethods\ndisable()\nPromise\n\nchrome.action.disable(\n  tabId?: number,\n  callback?: function,\n)\nDisables the action for a tab.\n\nPARAMETERS\ntabId\nnumber optional\n\nThe ID of the tab for which you want to modify the action.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nenable()\nPromise\n\nchrome.action.enable(\n  tabId?: number,\n  callback?: function,\n)\nEnables the action for a tab. By default, actions are enabled.\n\nPARAMETERS\ntabId\nnumber optional\n\nThe ID of the tab for which you want to modify the action.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetBadgeBackgroundColor()\nPromise\n\nchrome.action.getBadgeBackgroundColor(\n  details: TabDetails,\n  callback?: function,\n)\nGets the background color of the action.\n\nPARAMETERS\ndetails\nTabDetails\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(result: ColorArray) => void\nresult\nColorArray\n\nRETURNS\nPromise<browserAction.ColorArray>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetBadgeText()\nPromise\n\nchrome.action.getBadgeText(\n  details: TabDetails,\n  callback?: function,\n)\nGets the badge text of the action. If no tab is specified, the non-tab-specific badge text is returned. If displayActionCountAsBadgeText is enabled, a placeholder text will be returned unless the declarativeNetRequestFeedback permission is present or tab-specific badge text was provided.\n\nPARAMETERS\ndetails\nTabDetails\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(result: string) => void\nresult\nstring\n\nRETURNS\nPromise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetBadgeTextColor()\nPromise Chrome 110+\n\nchrome.action.getBadgeTextColor(\n  details: TabDetails,\n  callback?: function,\n)\nGets the text color of the action.\n\nPARAMETERS\ndetails\nTabDetails\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(result: ColorArray) => void\nresult\nColorArray\n\nRETURNS\nPromise<browserAction.ColorArray>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetPopup()\nPromise\n\nchrome.action.getPopup(\n  details: TabDetails,\n  callback?: function,\n)\nGets the html document set as the popup for this action.\n\nPARAMETERS\ndetails\nTabDetails\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(result: string) => void\nresult\nstring\n\nRETURNS\nPromise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetTitle()\nPromise\n\nchrome.action.getTitle(\n  details: TabDetails,\n  callback?: function,\n)\nGets the title of the action.\n\nPARAMETERS\ndetails\nTabDetails\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(result: string) => void\nresult\nstring\n\nRETURNS\nPromise<string>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetUserSettings()\nPromise Chrome 91+\n\nchrome.action.getUserSettings(\n  callback?: function,\n)\nReturns the user-specified settings relating to an extension's action.\n\nPARAMETERS\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(userSettings: UserSettings) => void\nuserSettings\nUserSettings\n\nRETURNS\nPromise<UserSettings>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nisEnabled()\nPromise Chrome 110+\n\nchrome.action.isEnabled(\n  tabId?: number,\n  callback?: function,\n)\nIndicates whether the extension action is enabled for a tab (or globally if no tabId is provided). Actions enabled using only declarativeContent always return false.\n\nPARAMETERS\ntabId\nnumber optional\n\nThe ID of the tab for which you want check enabled status.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(isEnabled: boolean) => void\nisEnabled\nboolean\n\nTrue if the extension action is enabled.\n\nRETURNS\nPromise<boolean>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nopenPopup()\nPromise Chrome 127+\n\nchrome.action.openPopup(\n  options?: OpenPopupOptions,\n  callback?: function,\n)\nOpens the extension's popup. Between Chrome 118 and Chrome 126, this is only available to policy installed extensions.\n\nPARAMETERS\noptions\nOpenPopupOptions optional\n\nSpecifies options for opening the popup.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetBadgeBackgroundColor()\nPromise\n\nchrome.action.setBadgeBackgroundColor(\n  details: object,\n  callback?: function,\n)\nSets the background color for the badge.\n\nPARAMETERS\ndetails\nobject\n\ncolor\nstring | ColorArray\n\nAn array of four integers in the range [0,255] that make up the RGBA color of the badge. For example, opaque red is [255, 0, 0, 255]. Can also be a string with a CSS value, with opaque red being #FF0000 or #F00.\n\ntabId\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetBadgeText()\nPromise\n\nchrome.action.setBadgeText(\n  details: object,\n  callback?: function,\n)\nSets the badge text for the action. The badge is displayed on top of the icon.\n\nPARAMETERS\ndetails\nobject\n\ntabId\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n\ntext\nstring optional\n\nAny number of characters can be passed, but only about four can fit in the space. If an empty string ('') is passed, the badge text is cleared. If tabId is specified and text is null, the text for the specified tab is cleared and defaults to the global badge text.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetBadgeTextColor()\nPromise Chrome 110+\n\nchrome.action.setBadgeTextColor(\n  details: object,\n  callback?: function,\n)\nSets the text color for the badge.\n\nPARAMETERS\ndetails\nobject\n\ncolor\nstring | ColorArray\n\nAn array of four integers in the range [0,255] that make up the RGBA color of the badge. For example, opaque red is [255, 0, 0, 255]. Can also be a string with a CSS value, with opaque red being #FF0000 or #F00. Not setting this value will cause a color to be automatically chosen that will contrast with the badge's background color so the text will be visible. Colors with alpha values equivalent to 0 will not be set and will return an error.\n\ntabId\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetIcon()\nPromise\n\nchrome.action.setIcon(\n  details: object,\n  callback?: function,\n)\nSets the icon for the action. The icon can be specified either as the path to an image file or as the pixel data from a canvas element, or as dictionary of either one of those. Either the path or the imageData property must be specified.\n\nPARAMETERS\ndetails\nobject\n\nimageData\nImageData | object optional\n\nEither an ImageData object or a dictionary {size -> ImageData} representing icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals scale, then image with size scale * n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.imageData = foo' is equivalent to 'details.imageData = {'16': foo}'\n\npath\nstring | object optional\n\nEither a relative image path or a dictionary {size -> relative image path} pointing to icon to be set. If the icon is specified as a dictionary, the actual image to be used is chosen depending on screen's pixel density. If the number of image pixels that fit into one screen space unit equals scale, then image with size scale * n will be selected, where n is the size of the icon in the UI. At least one image must be specified. Note that 'details.path = foo' is equivalent to 'details.path = {'16': foo}'\n\ntabId\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nChrome 96+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetPopup()\nPromise\n\nchrome.action.setPopup(\n  details: object,\n  callback?: function,\n)\nSets the HTML document to be opened as a popup when the user clicks on the action's icon.\n\nPARAMETERS\ndetails\nobject\n\npopup\nstring\n\nThe relative path to the HTML file to show in a popup. If set to the empty string (''), no popup is shown.\n\ntabId\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetTitle()\nPromise\n\nchrome.action.setTitle(\n  details: object,\n  callback?: function,\n)\nSets the title of the action. This shows up in the tooltip.\n\nPARAMETERS\ndetails\nobject\n\ntabId\nnumber optional\n\nLimits the change to when a particular tab is selected. Automatically resets when the tab is closed.\n\ntitle\nstring\n\nThe string the action should display when moused over.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nEvents\nonClicked\n\nchrome.action.onClicked.addListener(\n  callback: function,\n)\nFired when an action icon is clicked. This event will not fire if the action has a popup.\n\nPARAMETERS\ncallback\nfunction\n\nThe callback parameter looks like:\n\n\n(tab: tabs.Tab) => void\ntab\ntabs.Tab\n\nonUserSettingsChanged\nChrome 130+\n\nchrome.action.onUserSettingsChanged.addListener(\n  callback: function,\n)\nFired when user-specified settings relating to an extension's action change.\n\nPARAMETERS\ncallback\nfunction\n\nThe callback parameter looks like:\n\n\n(change: UserSettingsChange) => void\nchange\nUserSettingsChange\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/reference/api/action"
    ],
    [
      "selection:1732280701383",
      "Selected content from https://developer.chrome.com/docs/extensions/reference/api/sidePanel on 2024-11-22 13:05:01\n\nchrome.sidePanel \nbookmark_border\nOn this page\n\nDescription\nPermissions\nAvailability\nConcepts and usage\nUse cases\nSide panel user experience\nExamples\nTypes\n\nUse the chrome.sidePanel API to host content in the browser's side panel alongside the main content of a webpage.\n\nPermissions\nsidePanel\nTo use the Side Panel API, add the \"sidePanel\" permission in the extension manifest file:\n\nmanifest.json:\n\n\n{\n  \"name\": \"My side panel extension\",\n  ...\n  \"permissions\": [\n    \"sidePanel\"\n  ]\n}\nAvailability\nChrome 114+ MV3+\nConcepts and usage\nThe Side Panel API allows extensions to display their own UI in the side panel, enabling persistent experiences that complement the user's browsing journey.\n\n\nChrome browser side panel UI.\nSome features include:\n\nThe side panel remains open when navigating between tabs (if set to do so).\nIt can be available only on specific websites.\nAs an extension page, side panels have access to all Chrome APIs.\nWithin Chrome's settings, users can specify which side the panel should be displayed on.\nUse cases\nThe following sections demonstrate some common use cases for the Side Panel API. See Extension samples for complete extension examples.\n\nDisplay the same side panel on every site\nThe side panel can be set initially from the \"default_path\" property in the \"side_panel\" key of the manifest to display the same side panel on every site. This should point to a relative path within the extension directory.\n\nmanifest.json:\n\n\n{\n  \"name\": \"My side panel extension\",\n  ...\n  \"side_panel\": {\n    \"default_path\": \"sidepanel.html\"\n  }\n  ...\n}\nsidepanel.html:\n\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>My Sidepanel</title>\n  </head>\n  <body>\n    <h1>All sites sidepanel extension</h1>\n    <p>This side panel is enabled on all sites</p>\n  </body>\n</html>\nEnable a side panel on a specific site\nAn extension can use sidepanel.setOptions() to enable a side panel on a specific tab. This example uses chrome.tabs.onUpdated() to listen for any updates made to the tab. It checks if the URL is www.google.com and enables the side panel. Otherwise, it disables it.\n\nservice-worker.js:\n\n\nconst GOOGLE_ORIGIN = 'https://www.google.com';\n\nchrome.tabs.onUpdated.addListener(async (tabId, info, tab) => {\n  if (!tab.url) return;\n  const url = new URL(tab.url);\n  // Enables the side panel on google.com\n  if (url.origin === GOOGLE_ORIGIN) {\n    await chrome.sidePanel.setOptions({\n      tabId,\n      path: 'sidepanel.html',\n      enabled: true\n    });\n  } else {\n    // Disables the side panel on all other sites\n    await chrome.sidePanel.setOptions({\n      tabId,\n      enabled: false\n    });\n  }\n});\nWhen a user temporarily switches to a tab where the side panel is not enabled, the side panel will be hidden. It will automatically show again when the user switches to a tab where it was previously open.\n\nWhen the user navigates to a site where the side panel is not enabled, the side panel will close, and the extension won't show in the side panel drop-down menu.\n\nFor a complete example, see the Tab-specific side panel sample.\n\nOpen the side panel by clicking the toolbar icon\nDevelopers can allow users to open the side panel when they click the action toolbar icon with sidePanel.setPanelBehavior(). First, declare the \"action\" key in the manifest:\n\nmanifest.json:\n\n\n{\n  \"name\": \"My side panel extension\",\n  ...\n  \"action\": {\n    \"default_title\": \"Click to open panel\"\n  },\n  ...\n}\nNow, add this code to the previous example:\n\nservice-worker.js:\n\n\nconst GOOGLE_ORIGIN = 'https://www.google.com';\n\n// Allows users to open the side panel by clicking on the action toolbar icon\nchrome.sidePanel\n  .setPanelBehavior({ openPanelOnActionClick: true })\n  .catch((error) => console.error(error));\n...\nProgrammatically open the side panel on user interaction\nChrome 116 introduces sidePanel.open(). It allows extensions to open the side panel through an extension user gesture, such as clicking on the action icon. Or a user interaction on an extension page or content script, such as clicking a button. For a complete demo, see the Open Side Panel sample extension.\n\nThe following code shows how to open a global side panel on the current window when the user clicks on a context menu. When using sidePanel.open(), you must choose the context in which it should open. Use windowId to open a global side panel. Alternatively, set the tabId to open the side panel only on a specific tab.\n\nservice-worker.js:\n\n\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.contextMenus.create({\n    id: 'openSidePanel',\n    title: 'Open side panel',\n    contexts: ['all']\n  });\n});\n\nchrome.contextMenus.onClicked.addListener((info, tab) => {\n  if (info.menuItemId === 'openSidePanel') {\n    // This will open the panel in all the pages on the current window.\n    chrome.sidePanel.open({ windowId: tab.windowId });\n  }\n});\nKey point: Remember to design your side panel as a useful companion tool for users, improving their browsing experience without unnecessary distractions. Check the Quality Guidelines in the Program Policies for more info.\nSwitch to a different panel\nExtensions can use sidepanel.getOptions() to retrieve the current side panel. The following example sets a welcome side panel on runtime.onInstalled(). Then when the user navigates to a different tab, it replaces it with the main side panel.\n\nservice-worker.js:\n\n\nconst welcomePage = 'sidepanels/welcome-sp.html';\nconst mainPage = 'sidepanels/main-sp.html';\n\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.sidePanel.setOptions({ path: welcomePage });\n  chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true });\n});\n\nchrome.tabs.onActivated.addListener(async ({ tabId }) => {\n  const { path } = await chrome.sidePanel.getOptions({ tabId });\n  if (path === welcomePage) {\n    chrome.sidePanel.setOptions({ path: mainPage });\n  }\n});\nSee the Multiple side panels sample for the full code.\n\nSide panel user experience\nUsers will see Chrome's built-in side panels first. Each side panel displays the extension's icon in the side panel menu. If no icons are included, it will show a placeholder icon with the first letter of the extension's name.\n\nOpen the side panel\nTo allow users to open the side panel, use an action icon in combination with sidePanel.setPanelBehavior(). Alternatively, make a call to sidePanel.open() following a user interaction, such as:\n\nAn action click\nA keyboard shortcut\nA context menu\nA user gesture on an extension page or content script.\nPin the side panel\n\nPin icon in side panel UI.\nThe side panel toolbar displays a pin icon when your side panel is open. Clicking the icon pins your extension's action icon. Clicking the action icon once pinned will perform the default action for your action icon and will only open the side panel if this has been explicitly configured.\n\nExamples\nFor more Side Panel API extensions demos, explore any of the following extensions:\n\nDictionary side panel.\nGlobal side panel.\nMultiple side panels.\nOpen Side panel.\nSite-specific side panel.\nTypes\nGetPanelOptions\nPROPERTIES\ntabId\nnumber optional\n\nIf specified, the side panel options for the given tab will be returned. Otherwise, returns the default side panel options (used for any tab that doesn't have specific settings).\n\nOpenOptions\nChrome 116+\nPROPERTIES\ntabId\nnumber optional\n\nThe tab in which to open the side panel. If the corresponding tab has a tab-specific side panel, the panel will only be open for that tab. If there is not a tab-specific panel, the global panel will be open in the specified tab and any other tabs without a currently-open tab- specific panel. This will override any currently-active side panel (global or tab-specific) in the corresponding tab. At least one of this or windowId must be provided.\n\nwindowId\nnumber optional\n\nThe window in which to open the side panel. This is only applicable if the extension has a global (non-tab-specific) side panel or tabId is also specified. This will override any currently-active global side panel the user has open in the given window. At least one of this or tabId must be provided.\n\nPanelBehavior\nPROPERTIES\nopenPanelOnActionClick\nboolean optional\n\nWhether clicking the extension's icon will toggle showing the extension's entry in the side panel. Defaults to false.\n\nPanelOptions\nPROPERTIES\nenabled\nboolean optional\n\nWhether the side panel should be enabled. This is optional. The default value is true.\n\npath\nstring optional\n\nThe path to the side panel HTML file to use. This must be a local resource within the extension package.\n\ntabId\nnumber optional\n\nIf specified, the side panel options will only apply to the tab with this id. If omitted, these options set the default behavior (used for any tab that doesn't have specific settings). Note: if the same path is set for this tabId and the default tabId, then the panel for this tabId will be a different instance than the panel for the default tabId.\n\nSidePanel\nPROPERTIES\ndefault_path\nstring\n\nDeveloper specified path for side panel display.\n\nMethods\ngetOptions()\nPromise\n\nchrome.sidePanel.getOptions(\n  options: GetPanelOptions,\n  callback?: function,\n)\nReturns the active panel configuration.\n\nPARAMETERS\noptions\nGetPanelOptions\n\nSpecifies the context to return the configuration for.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(options: PanelOptions) => void\noptions\nPanelOptions\n\nRETURNS\nPromise<PanelOptions>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetPanelBehavior()\nPromise\n\nchrome.sidePanel.getPanelBehavior(\n  callback?: function,\n)\nReturns the extension's current side panel behavior.\n\nPARAMETERS\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(behavior: PanelBehavior) => void\nbehavior\nPanelBehavior\n\nRETURNS\nPromise<PanelBehavior>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nopen()\nPromise Chrome 116+\n\nchrome.sidePanel.open(\n  options: OpenOptions,\n  callback?: function,\n)\nOpens the side panel for the extension. This may only be called in response to a user action.\n\nPARAMETERS\noptions\nOpenOptions\n\nSpecifies the context in which to open the side panel.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetOptions()\nPromise\n\nchrome.sidePanel.setOptions(\n  options: PanelOptions,\n  callback?: function,\n)\nConfigures the side panel.\n\nPARAMETERS\noptions\nPanelOptions\n\nThe configuration options to apply to the panel.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetPanelBehavior()\nPromise\n\nchrome.sidePanel.setPanelBehavior(\n  behavior: PanelBehavior,\n  callback?: function,\n)\nConfigures the extension's side panel behavior. This is an upsert operation.\n\nPARAMETERS\nbehavior\nPanelBehavior\n\nThe new behavior to be set.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/reference/api/sidePanel"
    ],
    [
      "selection:1732280744188",
      "Selected content from https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest on 2024-11-22 13:05:44\n\nchrome.declarativeNetRequest \nbookmark_border\nOn this page\n\nDescription\nPermissions\nAvailability\nManifest\nRules and rulesets\n\nThe chrome.declarativeNetRequest API is used to block or modify network requests by specifying declarative rules. This lets extensions modify network requests without intercepting them and viewing their content, thus providing more privacy.\n\nPermissions\ndeclarativeNetRequest\ndeclarativeNetRequestWithHostAccess\nThe \"declarativeNetRequest\" and \"declarativeNetRequestWithHostAccess\" permissions provide the same capabilities. The differences between them is when permissions are requested or granted.\n\n\"declarativeNetRequest\"\nTriggers a permission warning at install time but provides implicit access to allow, allowAllRequests and block rules. Use this when possible to avoid needing to request full access to hosts.\n\"declarativeNetRequestFeedback\"\nEnables debugging features for unpacked extensions, specifically getMatchedRules() and onRuleMatchedDebug.\n\"declarativeNetRequestWithHostAccess\"\nA permission warning is not shown at install time, but you must request host permissions before you can perform any action on a host. This is appropriate when you want to use declarative net request rules in an extension which already has host permissions without generating additional warnings.\nAvailability\nChrome 84+\nManifest\nIn addition to the permissions described previously, certain types of rulesets, static rulesets specifically, require declaring the \"declarative_net_request\" manifest key, which should be a dictionary with a single key called \"rule_resources\". This key is an array containing dictionaries of type Ruleset, as shown in the following. (Note that the name 'Ruleset' does not appear in the manifest's JSON since it is merely an array.) Static rulesets are explained later in this document.\n\n\n{\n  \"name\": \"My extension\",\n  ...\n\n  \"declarative_net_request\" : {\n    \"rule_resources\" : [{\n      \"id\": \"ruleset_1\",\n      \"enabled\": true,\n      \"path\": \"rules_1.json\"\n    }, {\n      \"id\": \"ruleset_2\",\n      \"enabled\": false,\n      \"path\": \"rules_2.json\"\n    }]\n  },\n  \"permissions\": [\n    \"declarativeNetRequest\",\n    \"declarativeNetRequestFeedback\",\n  ],\n  \"host_permissions\": [\n    \"http://www.blogger.com/*\",\n    \"http://*.google.com/*\"\n  ],\n  ...\n}\nRules and rulesets\nTo use this API, specify one or more rulesets. A ruleset contains an array of rules. A single rule does one of the following:\n\nBlock a network request.\nUpgrade the schema (http to https).\nPrevent a request from getting blocked by negating any matching blocked rules.\nRedirect a network request.\nModify request or response headers.\nThere are three types of rulesets, managed in slightly different ways.\n\nDynamic\nPersist across browser sessions and extension upgrades and are managed using JavaScript while an extension is in use.\nSession\nCleared when the browser shuts down and when a new version of the extension is installed. Session rules are managed using JavaScript while an extension is in use.\nStatic\nPackaged, installed, and updated when an extension is installed or upgraded. Static rules are stored in JSON-formatted rule files and listed in the manifest file.\nDynamic and session-scoped rulesets\nDynamic and session rulesets are managed using JavaScript while an extension is in use.\n\nDynamic rules persist across browser sessions and extension upgrades.\nSession rules are cleared when the browser shuts down and when a new version of the extension is installed.\nThere is only one each of these ruleset types. An extension can add or remove rules to them dynamically by calling updateDynamicRules() and updateSessionRules(), provided the rule limits aren't exceeded. For information on rule limits, see Rule limits. You can see an example of this under code examples.\n\nStatic rulesets\nUnlike dynamic and session rules, static rules are packaged, installed, and updated when an extension is installed or upgraded. They're stored in rule files in JSON format, which are indicated to the extension using the \"declarative_net_request\" and \"rule_resources\" keys as described above, as well as one or more Ruleset dictionaries. A Ruleset dictionary contains a path to the rule file, an ID for the ruleset contained in the file, and whether the ruleset is enabled or disabled. The last two are important when you enable or disable a ruleset programmatically.\n\n\n{\n  ...\n  \"declarative_net_request\" : {\n    \"rule_resources\" : [{\n      \"id\": \"ruleset_1\",\n      \"enabled\": true,\n      \"path\": \"rules_1.json\"\n    },\n    ...\n    ]\n  }\n  ...\n}\nTo test rule files, load your extension unpacked. Errors and warnings about invalid static rules are only displayed for unpacked extensions. Invalid static rules in packed extensions are ignored.\n\nExpedited review\nChanges to static rulesets may be eligible for expedited review. See expedited review for eligible changes.\n\nEnable and disable static rules and rulesets\nBoth individual static rules and complete static rulesets may be enabled or disabled at runtime.\n\nThe set of enabled static rules and rulesets is persisted across browser sessions. Neither are persisted across extension updates, meaning that only rules you chose to leave in your rule files are available after an update.\n\nFor performance reasons there are also limits to the number of rules and rulesets that may be enabled at one time. Call getAvailableStaticRuleCount() to check the number of additional rules that may be enabled. For information on rule limits, see Rule limits.\n\nTo enable or disable static rules, call updateStaticRules(). This method takes an UpdateStaticRulesOptions object, which contains arrays of IDs of rules to enable or disable. The IDs are defined using the \"id\" key of the Ruleset dictionary. There is a maximum limit of 5000 disabled static rules.\n\nTo enable or disable static rulesets, call updateEnabledRulesets(). This method takes an UpdateRulesetOptions object, which contains arrays of IDs of rulesets to enable or disable. The IDs are defined using the \"id\" key of the Ruleset dictionary.\n\nBuild rules\nRegardless of type, a rule starts with four fields as shown in the following. While the \"id\" and \"priority\" keys take a number, the \"action\" and \"condition\" keys may provide several blocking and redirecting conditions. The following rule blocks all script requests originating from \"foo.com\" to any URL with \"abc\" as a substring.\n\n\n{\n  \"id\" : 1,\n  \"priority\": 1,\n  \"action\" : { \"type\" : \"block\" },\n  \"condition\" : {\n    \"urlFilter\" : \"abc\",\n    \"initiatorDomains\" : [\"foo.com\"],\n    \"resourceTypes\" : [\"script\"]\n  }\n}\nURL matching\nDeclarative Net Request provides the ability to match URLs with either a pattern matching syntax or regular expressions.\n\nURL filter syntax\nA rule's \"condition\" key allows a \"urlFilter\" key for acting on URLs under a specified domain. You create patterns using pattern matching tokens. Here are a few examples.\n\nurlFilter\tMatches\tDoes not match\n\"abc\"\thttps://abcd.com\nhttps://example.com/abcd\thttps://ab.com\n\"abc*d\"\thttps://abcd.com\nhttps://example.com/abcxyzd\thttps://abc.com\n\"||a.example.com\"\thttps://a.example.com/\nhttps://b.a.example.com/xyz\nhttps://a.example.company\thttps://example.com/\n\"|https*\"\thttps://example.com\thttp://example.com/\nhttp://https.com\n\"example*^123|\"\thttps://example.com/123\nhttp://abc.com/example?123\thttps://example.com/1234\nhttps://abc.com/example0123\nRegular expressions\nConditions can also use regular expressions. See the \"regexFilter\" key. To learn about the limits that apply to these conditions, see Rules that use regular expressions.\n\nWrite good URL conditions\nTake care when writing rules to always match an entire domain. Otherwise, your rule may match in situations that are unexpected. For example, when using the pattern matching syntax:\n\ngoogle.com incorrectly matches https://example.com/?param=google.com\n||google.com incorrectly matches https://google.company\nhttps://www.google.com incorrectly matches https://example.com/?param=https://www.google.com\nConsider using:\n\n||google.com/, which matches all paths and all subdomains.\n|https://www.google.com/ which matches all paths and no subdomains.\nSimilarly, use the ^ and / characters to anchor a regular expression. For example, ^https:\\/\\/www\\.google\\.com\\/ matches any path on https://www.google.com.\n\nRule evaluation\nDNR rules are applied by the browser across various stages of the network request lifecycle.\n\nBefore the request\nBefore a request is made, an extension can block or redirect (including upgrading the scheme from HTTP to HTTPS) it with a matching rule.\n\nFor each extension, the browser determines a list of matching rules. Rules with a modifyHeaders action are not included here as they will be handled later. Additionally, rules with a responseHeaders condition will be considered later (when response headers are available) and are not included.\n\nThen, for each extension, Chrome picks at most one candidate per request. Chrome finds a matching rule, by ordering all matching rules by priority. Rules with the same priority are ordered by action (allow or allowAllRequests > block > upgradeScheme > redirect).\n\nIf the candidate is an allow or allowAllRequests rule, or the frame the request is being made in previously matched an allowAllRequests rule of higher or equal priority from this extension, the request is \"allowed\" and the extension won't have any effect on the request.\n\nIf more than one extension wants to block or redirect this request, a single action to take is chosen. Chrome does this by sorting the rules in the order block > redirect or upgradeScheme > allow or allowAllRequests. If two rules are of the same type, Chrome chooses the rule from the most recently installed extension.\n\nCaution: Browser vendors have agreed not to standardize the order in which rules with the same action and priority run. This can change between runs or browser versions, even when spread between multiple types of ruleset (such as a static rule and a session rule). When ordering is important, you should always explicitly specify a priority.\nBefore request headers are sent\nBefore Chrome sends request headers to the server, the headers are updated based on matching modifyHeaders rules.\n\nWithin a single extension, Chrome builds the list of modifications to perform by finding all matching modifyHeaders rules. Similar to before, only rules which have a higher priority than any matching allow or allowAllRequests rules are included.\n\nThese rules are applied by Chrome in an order such that rules from a more recently installed extension are always evaluated before rules from an older extension. Additionally, rules of a higher priority from one extension are always applied before rules of a lower priority from the same extension. Notably, even across extensions:\n\nIf a rule appends to a header, then lower priority rules can only append to that header. Set and remove operations are not allowed.\nIf a rule sets a header, then only lower priority rules from the same extension can append to that header. No other modifications are allowed.\nIf a rule removes a header, then lower priority rules cannot further modify the header.\nOnce a response is received\nOnce the response headers have been received, Chrome evaluates rules with a responseHeaders condition.\n\nAfter sorting these rules by action and priority and excluding any rules made redundant by a matching allow or allowAllRequests rule (this happens identically to the steps in \"Before the request\"), Chrome may block or redirect the request on behalf of an extension.\n\nNote that if a request made it to this stage, the request has already been sent to the server and the server has received data like the request body. A block or redirect rule with a response headers condition will still run–but cannot actually block or redirect the request.\n\nIn the case of a block rule, this is handled by the page which made the request receiving a blocked response and Chrome terminating the request early. In the case of a redirect rule, Chrome makes a new request to the redirected URL. Make sure to consider if these behaviors meet the privacy expectations for your extension.\n\nIf the request is not blocked or redirected, Chrome applies any modifyHeaders rules. Applying modifications to response headers works in the same way as described in \"Before request headers are sent\". Applying modifications to request headers does nothing, since the request has already been made.\n\nSafe rules\nSafe rules are defined as rules with an action of block, allow, allowAllRequests or upgradeScheme. These rules are subject to an increased dynamic rules quota.\n\nRule limits\nThere is a performance overhead to loading and evaluating rules in the browser, so some limits apply when using the API. Limits depend on the type of rule you're using.\n\nStatic rules\nStatic rules are those specified in rule files declared in the manifest file. An extension can specify up to 100 static rulesets as part of the \"rule_resources\" manifest key, but only 50 of these rulesets can be enabled at a time. The latter is called the MAX_NUMBER_OF_ENABLED_STATIC_RULESETS. Collectively, those rulesets are guaranteed at least 30,000 rules. This is called the GUARANTEED_MINIMUM_STATIC_RULES.\n\nNote: Prior to Chrome 120, extensions were limited to a total of 50 static rulesets, and only 10 of these could be enabled at the same time. Use the minimum_chrome_version manifest field to limit which Chrome versions can install your extension.\nThe number of rules available after that depends on how many rules are enabled by all the extensions installed on a user's browser. You can find this number at runtime by calling getAvailableStaticRuleCount(). You can see an example of this under code examples.\n\nNote: Starting with Chrome 128, if a user disables an extension through chrome://extensions, the extension's static rules will no longer count towards the global static rule limit. This potentially frees up static rule quota for other extensions, but also means that when the extension gets re-enabled, it might have fewer static rules available than before.\nSession rules\nAn extension can have up to 5000 session rules. This is exposed as the MAX_NUMBER_OF_SESSION_RULES.\n\nBefore Chrome 120, there was a limit of 5000 combined dynamic and session rules.\n\nDynamic rules\nAn extension can have at least 5000 dynamic rules. This is exposed as the MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES.\n\nStarting in Chrome 121, there is a larger limit of 30,000 rules available for safe dynamic rules, exposed as the MAX_NUMBER_OF_DYNAMIC_RULES. Any unsafe rules added within the limit of 5000 will also count towards this limit.\n\nBefore Chrome 120, there was a 5000 combined dynamic and session rules limit.\n\nRules that use regular expressions\nAll types of rules can use regular expressions; however, the total number of regular expression rules of each type cannot exceed 1000. This is called the MAX_NUMBER_OF_REGEX_RULES.\n\nAdditionally, each rule must be less than 2KB once compiled. This roughly correlates with the complexity of the rule. If you try to load a rule that exceeds this limit, you will see a warning like the following and the rule will be ignored.\n\n\nrules_1.json: Rule with id 1 specified a more complex regex than allowed\nas part of the \"regexFilter\" key.\nInteractions with service workers\nA declarativeNetRequest only applies to requests that reach the network stack. This includes responses from the HTTP cache, but may not include responses that go through a service worker's onfetch handler. declarativeNetRequest won't affect responses generated by the service worker or retrieved from CacheStorage, but it will affect calls to fetch() made in a service worker.\n\nWeb accessible resources\nA declarativeNetRequest rule cannot redirect from a public resource request to a resource that is not web accessible. Doing so triggers an error. This is true even if the specified web accessible resource is owned by the redirecting extension. To declare resources for declarativeNetRequest, use the manifest's \"web_accessible_resources\" array.\n\nHeader modification\nThe append operation is only supported for the following headers: accept, accept-encoding, accept-language, access-control-request-headers, cache-control, connection, content-language, cookie, forwarded, if-match, if-none-match, keep-alive, range, te, trailer, transfer-encoding, upgrade, user-agent, via, want-digest, x-forwarded-for.\n\nExamples\nCode examples\nUpdate dynamic rules\nThe following example shows how to call updateDynamicRules(). The procedure for updateSessionRules() is the same.\n\n\n// Get arrays containing new and old rules\nconst newRules = await getNewRules();\nconst oldRules = await chrome.declarativeNetRequest.getDynamicRules();\nconst oldRuleIds = oldRules.map(rule => rule.id);\n\n// Use the arrays to update the dynamic rules\nawait chrome.declarativeNetRequest.updateDynamicRules({\n  removeRuleIds: oldRuleIds,\n  addRules: newRules\n});\nUpdate static rulesets\nThe following example shows how to enable and disable rulesets while considering the number of available and the maximum number of enabled static rulesets. You would do this when the number of static rules you need exceeds the number allowed. For this to work, some of your rulesets should be installed with some of your rulesets disabled (setting \"Enabled\" to false within the manifest file).\n\n\nasync function updateStaticRules(enableRulesetIds, disableCandidateIds) {\n  // Create the options structure for the call to updateEnabledRulesets()\n  let options = { enableRulesetIds: enableRulesetIds }\n  // Get the number of enabled static rules\n  const enabledStaticCount = await chrome.declarativeNetRequest.getEnabledRulesets();\n  // Compare rule counts to determine if anything needs to be disabled so that\n  // new rules can be enabled\n  const proposedCount = enableRulesetIds.length;\n  if (enabledStaticCount + proposedCount > chrome.declarativeNetRequest.MAX_NUMBER_OF_ENABLED_STATIC_RULESETS) {\n    options.disableRulesetIds = disableCandidateIds\n  }\n  // Update the enabled static rules\n  await chrome.declarativeNetRequest.updateEnabledRulesets(options);\n}\nRule examples\nThe following examples illustrate how Chrome prioritizes rules in an extension. When reviewing them, you may want to open the prioritization rules in a separate window.\n\nThe \"priority\" key\nThese examples require host permission to *://*.example.com/*.\n\nTo work out the priority of a particular URL, look at the (developer-defined) \"priority\" key, the \"action\" key and the \"urlFilter\" key. These examples refer to the example rule file shown below them.\n\nNavigation to https://google.com\nTwo rules cover this URL: the rules with IDs 1 and 4. The rule with ID 1 applies because \"block\" actions have a higher priority than \"redirect\" actions. The remaining rules don't apply because they are for longer URLs.\nNavigation to https://google.com/1234\nBecause of the longer URL, the rule with ID 2 now matches in addition to the rules with IDs 1 and 4. The rule with ID 2 applies because \"allow\" has a higher priority than \"block\" and \"redirect\".\nNavigation to https://google.com/12345\nAll four rules match this URL. The rule with ID 3 applies because its developer-defined priority is the highest of the group.\n\n[\n  {\n    \"id\": 1,\n    \"priority\": 1,\n    \"action\": { \"type\": \"block\" },\n    \"condition\": {\"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n  },\n  {\n    \"id\": 2,\n    \"priority\": 1,\n    \"action\": { \"type\": \"allow\" },\n    \"condition\": { \"urlFilter\": \"||google.com/123\", \"resourceTypes\": [\"main_frame\"] }\n  },\n  {\n    \"id\": 3,\n    \"priority\": 2,\n    \"action\": { \"type\": \"block\" },\n    \"condition\": { \"urlFilter\": \"||google.com/12345\", \"resourceTypes\": [\"main_frame\"] }\n  },\n  {\n    \"id\": 4,\n    \"priority\": 1,\n    \"action\": { \"type\": \"redirect\", \"redirect\": { \"url\": \"https://example.com\" } },\n    \"condition\": { \"urlFilter\": \"||google.com/\", \"resourceTypes\": [\"main_frame\"] }\n  },\n]\nRedirects\nThe example below requires host permission to *://*.example.com/*.\n\nThe following example shows how to redirect a request from example.com to a page within the extension itself. The extension path /a.jpg resolves to chrome-extension://EXTENSION_ID/a.jpg, where EXTENSION_ID is the ID of your extension. For this to work the manifest should declare /a.jpg as a web accessible resource.\n\n\n{\n  \"id\": 1,\n  \"priority\": 1,\n  \"action\": { \"type\": \"redirect\", \"redirect\": { \"extensionPath\": \"/a.jpg\" } },\n  \"condition\": {\n    \"urlFilter\": \"||https://www.example.com/\",\n    \"resourceTypes\": [\"main_frame\"]\n  }\n}\nThe following uses the \"transform\" key to redirect to a subdomain of example.com. It uses a domain name anchor (\"||\") to intercept requests with any scheme from example.com. The \"scheme\" key in \"transform\" specifies that redirects to the subdomain will always use \"https\".\n\n\n{\n  \"id\": 1,\n  \"priority\": 1,\n  \"action\": {\n    \"type\": \"redirect\",\n    \"redirect\": {\n      \"transform\": { \"scheme\": \"https\", \"host\": \"new.example.com\" }\n    }\n  },\n  \"condition\": {\n    \"urlFilter\": \"||example.com/\",\n    \"resourceTypes\": [\"main_frame\"]\n  }\n}\nThe following example uses regular expressions to redirect from https://www.abc.xyz.com/path to https://abc.xyz.com/path. In the \"regexFilter\" key, notice how periods are escaped and that the capturing group selects either \"abc\" or \"def\". The \"regexSubstitution\" key specifies the first returned match of the regular expression using \"\\1\". In this case, \"abc\" is captured from the redirected URL and placed in the substitution.\n\n\n{\n  \"id\": 1,\n  \"priority\": 1,\n  \"action\": {\n    \"type\": \"redirect\",\n    \"redirect\": {\n      \"regexSubstitution\": \"https://\\\\1.xyz.com/\"\n    }\n  },\n  \"condition\": {\n    \"regexFilter\": \"^https://www\\\\.(abc|def)\\\\.xyz\\\\.com/\",\n    \"resourceTypes\": [\n      \"main_frame\"\n    ]\n  }\n}\nHeaders\nThe following example removes all cookies from both a main frame and any sub frames.\n\n\n{\n  \"id\": 1,\n  \"priority\": 1,\n  \"action\": {\n    \"type\": \"modifyHeaders\",\n    \"requestHeaders\": [{ \"header\": \"cookie\", \"operation\": \"remove\" }]\n  },\n  \"condition\": { \"resourceTypes\": [\"main_frame\", \"sub_frame\"] }\n}\nTypes\nDomainType\nThis describes whether the request is first or third party to the frame in which it originated. A request is said to be first party if it has the same domain (eTLD+1) as the frame in which the request originated.\n\nENUM\n\n\"firstParty\"\nThe network request is first party to the frame in which it originated.\n\n\"thirdParty\"\nThe network request is third party to the frame in which it originated.\n\nExtensionActionOptions\nChrome 88+\nPROPERTIES\ndisplayActionCountAsBadgeText\nboolean optional\n\nWhether to automatically display the action count for a page as the extension's badge text. This preference is persisted across sessions.\n\ntabUpdate\nTabActionCountUpdate optional\n\nChrome 89+\nDetails of how the tab's action count should be adjusted.\n\nGetDisabledRuleIdsOptions\nChrome 111+\nPROPERTIES\nrulesetId\nstring\n\nThe id corresponding to a static Ruleset.\n\nGetRulesFilter\nChrome 111+\nPROPERTIES\nruleIds\nnumber[] optional\n\nIf specified, only rules with matching IDs are included.\n\nHeaderInfo\nChrome 128+\nPROPERTIES\nexcludedValues\nstring[] optional\n\nIf specified, this condition is not matched if the header exists but its value contains at least one element in this list. This uses the same match pattern syntax as values.\n\nheader\nstring\n\nThe name of the header. This condition matches on the name only if both values and excludedValues are not specified.\n\nvalues\nstring[] optional\n\nIf specified, this condition matches if the header's value matches at least one pattern in this list. This supports case-insensitive header value matching plus the following constructs:\n\n'*' : Matches any number of characters.\n\n'?' : Matches zero or one character(s).\n\n'*' and '?' can be escaped with a backslash, e.g. '\\*' and '\\?'\n\nHeaderOperation\nChrome 86+\nThis describes the possible operations for a \"modifyHeaders\" rule.\n\nENUM\n\n\"append\"\nAdds a new entry for the specified header. This operation is not supported for request headers.\n\n\"set\"\nSets a new value for the specified header, removing any existing headers with the same name.\n\n\"remove\"\nRemoves all entries for the specified header.\n\nIsRegexSupportedResult\nChrome 87+\nPROPERTIES\nisSupported\nboolean\n\nreason\nUnsupportedRegexReason optional\n\nSpecifies the reason why the regular expression is not supported. Only provided if isSupported is false.\n\nMatchedRule\nPROPERTIES\nruleId\nnumber\n\nA matching rule's ID.\n\nrulesetId\nstring\n\nID of the Ruleset this rule belongs to. For a rule originating from the set of dynamic rules, this will be equal to DYNAMIC_RULESET_ID.\n\nMatchedRuleInfo\nPROPERTIES\nrule\nMatchedRule\n\ntabId\nnumber\n\nThe tabId of the tab from which the request originated if the tab is still active. Else -1.\n\ntimeStamp\nnumber\n\nThe time the rule was matched. Timestamps will correspond to the Javascript convention for times, i.e. number of milliseconds since the epoch.\n\nMatchedRuleInfoDebug\nPROPERTIES\nrequest\nRequestDetails\n\nDetails about the request for which the rule was matched.\n\nrule\nMatchedRule\n\nMatchedRulesFilter\nPROPERTIES\nminTimeStamp\nnumber optional\n\nIf specified, only matches rules after the given timestamp.\n\ntabId\nnumber optional\n\nIf specified, only matches rules for the given tab. Matches rules not associated with any active tab if set to -1.\n\nModifyHeaderInfo\nChrome 86+\nPROPERTIES\nheader\nstring\n\nThe name of the header to be modified.\n\noperation\nHeaderOperation\n\nThe operation to be performed on a header.\n\nvalue\nstring optional\n\nThe new value for the header. Must be specified for append and set operations.\n\nQueryKeyValue\nPROPERTIES\nkey\nstring\n\nreplaceOnly\nboolean optional\n\nChrome 94+\nIf true, the query key is replaced only if it's already present. Otherwise, the key is also added if it's missing. Defaults to false.\n\nvalue\nstring\n\nQueryTransform\nPROPERTIES\naddOrReplaceParams\nQueryKeyValue[] optional\n\nThe list of query key-value pairs to be added or replaced.\n\nremoveParams\nstring[] optional\n\nThe list of query keys to be removed.\n\nRedirect\nPROPERTIES\nextensionPath\nstring optional\n\nPath relative to the extension directory. Should start with '/'.\n\nregexSubstitution\nstring optional\n\nSubstitution pattern for rules which specify a regexFilter. The first match of regexFilter within the url will be replaced with this pattern. Within regexSubstitution, backslash-escaped digits (\\1 to \\9) can be used to insert the corresponding capture groups. \\0 refers to the entire matching text.\n\ntransform\nURLTransform optional\n\nUrl transformations to perform.\n\nurl\nstring optional\n\nThe redirect url. Redirects to JavaScript urls are not allowed.\n\nRegexOptions\nChrome 87+\nPROPERTIES\nisCaseSensitive\nboolean optional\n\nWhether the regex specified is case sensitive. Default is true.\n\nregex\nstring\n\nThe regular expresson to check.\n\nrequireCapturing\nboolean optional\n\nWhether the regex specified requires capturing. Capturing is only required for redirect rules which specify a regexSubstition action. The default is false.\n\nRequestDetails\nPROPERTIES\ndocumentId\nstring optional\n\nChrome 106+\nThe unique identifier for the frame's document, if this request is for a frame.\n\ndocumentLifecycle\nDocumentLifecycle optional\n\nChrome 106+\nThe lifecycle of the frame's document, if this request is for a frame.\n\nframeId\nnumber\n\nThe value 0 indicates that the request happens in the main frame; a positive value indicates the ID of a subframe in which the request happens. If the document of a (sub-)frame is loaded (type is main_frame or sub_frame), frameId indicates the ID of this frame, not the ID of the outer frame. Frame IDs are unique within a tab.\n\nframeType\nFrameType optional\n\nChrome 106+\nThe type of the frame, if this request is for a frame.\n\ninitiator\nstring optional\n\nThe origin where the request was initiated. This does not change through redirects. If this is an opaque origin, the string 'null' will be used.\n\nmethod\nstring\n\nStandard HTTP method.\n\nparentDocumentId\nstring optional\n\nChrome 106+\nThe unique identifier for the frame's parent document, if this request is for a frame and has a parent.\n\nparentFrameId\nnumber\n\nID of frame that wraps the frame which sent the request. Set to -1 if no parent frame exists.\n\nrequestId\nstring\n\nThe ID of the request. Request IDs are unique within a browser session.\n\ntabId\nnumber\n\nThe ID of the tab in which the request takes place. Set to -1 if the request isn't related to a tab.\n\ntype\nResourceType\n\nThe resource type of the request.\n\nurl\nstring\n\nThe URL of the request.\n\nRequestMethod\nChrome 91+\nThis describes the HTTP request method of a network request.\n\nENUM\n\n\"connect\"\n\n\"delete\"\n\n\"get\"\n\n\"head\"\n\n\"options\"\n\n\"patch\"\n\n\"post\"\n\n\"put\"\n\n\"other\"\n\nResourceType\nThis describes the resource type of the network request.\n\nENUM\n\n\"main_frame\"\n\n\"sub_frame\"\n\n\"stylesheet\"\n\n\"script\"\n\n\"image\"\n\n\"font\"\n\n\"object\"\n\n\"xmlhttprequest\"\n\n\"ping\"\n\n\"csp_report\"\n\n\"media\"\n\n\"websocket\"\n\n\"webtransport\"\n\n\"webbundle\"\n\n\"other\"\n\nRule\nPROPERTIES\naction\nRuleAction\n\nThe action to take if this rule is matched.\n\ncondition\nRuleCondition\n\nThe condition under which this rule is triggered.\n\nid\nnumber\n\nAn id which uniquely identifies a rule. Mandatory and should be >= 1.\n\npriority\nnumber optional\n\nRule priority. Defaults to 1. When specified, should be >= 1.\n\nRuleAction\nPROPERTIES\nredirect\nRedirect optional\n\nDescribes how the redirect should be performed. Only valid for redirect rules.\n\nrequestHeaders\nModifyHeaderInfo[] optional\n\nChrome 86+\nThe request headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n\nresponseHeaders\nModifyHeaderInfo[] optional\n\nChrome 86+\nThe response headers to modify for the request. Only valid if RuleActionType is \"modifyHeaders\".\n\ntype\nRuleActionType\n\nThe type of action to perform.\n\nRuleActionType\nDescribes the kind of action to take if a given RuleCondition matches.\n\nENUM\n\n\"block\"\nBlock the network request.\n\n\"redirect\"\nRedirect the network request.\n\n\"allow\"\nAllow the network request. The request won't be intercepted if there is an allow rule which matches it.\n\n\"upgradeScheme\"\nUpgrade the network request url's scheme to https if the request is http or ftp.\n\n\"modifyHeaders\"\nModify request/response headers from the network request.\n\n\"allowAllRequests\"\nAllow all requests within a frame hierarchy, including the frame request itself.\n\nRuleCondition\nPROPERTIES\ndomainType\nDomainType optional\n\nSpecifies whether the network request is first-party or third-party to the domain from which it originated. If omitted, all requests are accepted.\n\ndomains\nstring[] optional\n\nDeprecated since Chrome 101\nUse initiatorDomains instead\n\nThe rule will only match network requests originating from the list of domains.\n\nexcludedDomains\nstring[] optional\n\nDeprecated since Chrome 101\nUse excludedInitiatorDomains instead\n\nThe rule will not match network requests originating from the list of excludedDomains.\n\nexcludedInitiatorDomains\nstring[] optional\n\nChrome 101+\nThe rule will not match network requests originating from the list of excludedInitiatorDomains. If the list is empty or omitted, no domains are excluded. This takes precedence over initiatorDomains.\n\nNotes:\n\nSub-domains like \"a.example.com\" are also allowed.\nThe entries must consist of only ascii characters.\nUse punycode encoding for internationalized domains.\nThis matches against the request initiator and not the request url.\nSub-domains of the listed domains are also excluded.\nexcludedRequestDomains\nstring[] optional\n\nChrome 101+\nThe rule will not match network requests when the domains matches one from the list of excludedRequestDomains. If the list is empty or omitted, no domains are excluded. This takes precedence over requestDomains.\n\nNotes:\n\nSub-domains like \"a.example.com\" are also allowed.\nThe entries must consist of only ascii characters.\nUse punycode encoding for internationalized domains.\nSub-domains of the listed domains are also excluded.\nexcludedRequestMethods\nRequestMethod[] optional\n\nChrome 91+\nList of request methods which the rule won't match. Only one of requestMethods and excludedRequestMethods should be specified. If neither of them is specified, all request methods are matched.\n\nexcludedResourceTypes\nResourceType[] optional\n\nList of resource types which the rule won't match. Only one of resourceTypes and excludedResourceTypes should be specified. If neither of them is specified, all resource types except \"main_frame\" are blocked.\n\nexcludedResponseHeaders\nHeaderInfo[] optional\n\nChrome 128+\nRule does not match if the request matches any response header condition in this list (if specified). If both excludedResponseHeaders and responseHeaders are specified, then the excludedResponseHeaders property takes precedence.\n\nexcludedTabIds\nnumber[] optional\n\nChrome 92+\nList of tabs.Tab.id which the rule should not match. An ID of tabs.TAB_ID_NONE excludes requests which don't originate from a tab. Only supported for session-scoped rules.\n\ninitiatorDomains\nstring[] optional\n\nChrome 101+\nThe rule will only match network requests originating from the list of initiatorDomains. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.\n\nNotes:\n\nSub-domains like \"a.example.com\" are also allowed.\nThe entries must consist of only ascii characters.\nUse punycode encoding for internationalized domains.\nThis matches against the request initiator and not the request url.\nSub-domains of the listed domains are also matched.\nisUrlFilterCaseSensitive\nboolean optional\n\nWhether the urlFilter or regexFilter (whichever is specified) is case sensitive. Default is false.\n\nregexFilter\nstring optional\n\nRegular expression to match against the network request url. This follows the RE2 syntax.\n\nNote: Only one of urlFilter or regexFilter can be specified.\n\nNote: The regexFilter must be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8.\n\nrequestDomains\nstring[] optional\n\nChrome 101+\nThe rule will only match network requests when the domain matches one from the list of requestDomains. If the list is omitted, the rule is applied to requests from all domains. An empty list is not allowed.\n\nNotes:\n\nSub-domains like \"a.example.com\" are also allowed.\nThe entries must consist of only ascii characters.\nUse punycode encoding for internationalized domains.\nSub-domains of the listed domains are also matched.\nrequestMethods\nRequestMethod[] optional\n\nChrome 91+\nList of HTTP request methods which the rule can match. An empty list is not allowed.\n\nNote: Specifying a requestMethods rule condition will also exclude non-HTTP(s) requests, whereas specifying excludedRequestMethods will not.\n\nresourceTypes\nResourceType[] optional\n\nList of resource types which the rule can match. An empty list is not allowed.\n\nNote: this must be specified for allowAllRequests rules and may only include the sub_frame and main_frame resource types.\n\nresponseHeaders\nHeaderInfo[] optional\n\nChrome 128+\nRule matches if the request matches any response header condition in this list (if specified).\n\ntabIds\nnumber[] optional\n\nChrome 92+\nList of tabs.Tab.id which the rule should match. An ID of tabs.TAB_ID_NONE matches requests which don't originate from a tab. An empty list is not allowed. Only supported for session-scoped rules.\n\nurlFilter\nstring optional\n\nThe pattern which is matched against the network request url. Supported constructs:\n\n'*' : Wildcard: Matches any number of characters.\n\n'|' : Left/right anchor: If used at either end of the pattern, specifies the beginning/end of the url respectively.\n\n'||' : Domain name anchor: If used at the beginning of the pattern, specifies the start of a (sub-)domain of the URL.\n\n'^' : Separator character: This matches anything except a letter, a digit, or one of the following: _, -, ., or %. This also match the end of the URL.\n\nTherefore urlFilter is composed of the following parts: (optional Left/Domain name anchor) + pattern + (optional Right anchor).\n\nIf omitted, all urls are matched. An empty string is not allowed.\n\nA pattern beginning with ||* is not allowed. Use * instead.\n\nNote: Only one of urlFilter or regexFilter can be specified.\n\nNote: The urlFilter must be composed of only ASCII characters. This is matched against a url where the host is encoded in the punycode format (in case of internationalized domains) and any other non-ascii characters are url encoded in utf-8. For example, when the request url is http://abc.рф?q=ф, the urlFilter will be matched against the url http://abc.xn--p1ai/?q=%D1%84.\n\nRuleset\nPROPERTIES\nenabled\nboolean\n\nWhether the ruleset is enabled by default.\n\nid\nstring\n\nA non-empty string uniquely identifying the ruleset. IDs beginning with '_' are reserved for internal use.\n\npath\nstring\n\nThe path of the JSON ruleset relative to the extension directory.\n\nRulesMatchedDetails\nPROPERTIES\nrulesMatchedInfo\nMatchedRuleInfo[]\n\nRules matching the given filter.\n\nTabActionCountUpdate\nChrome 89+\nPROPERTIES\nincrement\nnumber\n\nThe amount to increment the tab's action count by. Negative values will decrement the count.\n\ntabId\nnumber\n\nThe tab for which to update the action count.\n\nTestMatchOutcomeResult\nChrome 103+\nPROPERTIES\nmatchedRules\nMatchedRule[]\n\nThe rules (if any) that match the hypothetical request.\n\nTestMatchRequestDetails\nChrome 103+\nPROPERTIES\ninitiator\nstring optional\n\nThe initiator URL (if any) for the hypothetical request.\n\nmethod\nRequestMethod optional\n\nStandard HTTP method of the hypothetical request. Defaults to \"get\" for HTTP requests and is ignored for non-HTTP requests.\n\nresponseHeaders\nobject optional\n\nChrome 129+\nThe headers provided by a hypothetical response if the request does not get blocked or redirected before it is sent. Represented as an object which maps a header name to a list of string values. If not specified, the hypothetical response would return empty response headers, which can match rules which match on the non-existence of headers. E.g. {\"content-type\": [\"text/html; charset=utf-8\", \"multipart/form-data\"]}\n\ntabId\nnumber optional\n\nThe ID of the tab in which the hypothetical request takes place. Does not need to correspond to a real tab ID. Default is -1, meaning that the request isn't related to a tab.\n\ntype\nResourceType\n\nThe resource type of the hypothetical request.\n\nurl\nstring\n\nThe URL of the hypothetical request.\n\nUnsupportedRegexReason\nChrome 87+\nDescribes the reason why a given regular expression isn't supported.\n\nENUM\n\n\"syntaxError\"\nThe regular expression is syntactically incorrect, or uses features not available in the RE2 syntax.\n\n\"memoryLimitExceeded\"\nThe regular expression exceeds the memory limit.\n\nUpdateRuleOptions\nChrome 87+\nPROPERTIES\naddRules\nRule[] optional\n\nRules to add.\n\nremoveRuleIds\nnumber[] optional\n\nIDs of the rules to remove. Any invalid IDs will be ignored.\n\nUpdateRulesetOptions\nChrome 87+\nPROPERTIES\ndisableRulesetIds\nstring[] optional\n\nThe set of ids corresponding to a static Ruleset that should be disabled.\n\nenableRulesetIds\nstring[] optional\n\nThe set of ids corresponding to a static Ruleset that should be enabled.\n\nUpdateStaticRulesOptions\nChrome 111+\nPROPERTIES\ndisableRuleIds\nnumber[] optional\n\nSet of ids corresponding to rules in the Ruleset to disable.\n\nenableRuleIds\nnumber[] optional\n\nSet of ids corresponding to rules in the Ruleset to enable.\n\nrulesetId\nstring\n\nThe id corresponding to a static Ruleset.\n\nURLTransform\nPROPERTIES\nfragment\nstring optional\n\nThe new fragment for the request. Should be either empty, in which case the existing fragment is cleared; or should begin with '#'.\n\nhost\nstring optional\n\nThe new host for the request.\n\npassword\nstring optional\n\nThe new password for the request.\n\npath\nstring optional\n\nThe new path for the request. If empty, the existing path is cleared.\n\nport\nstring optional\n\nThe new port for the request. If empty, the existing port is cleared.\n\nquery\nstring optional\n\nThe new query for the request. Should be either empty, in which case the existing query is cleared; or should begin with '?'.\n\nqueryTransform\nQueryTransform optional\n\nAdd, remove or replace query key-value pairs.\n\nscheme\nstring optional\n\nThe new scheme for the request. Allowed values are \"http\", \"https\", \"ftp\" and \"chrome-extension\".\n\nusername\nstring optional\n\nThe new username for the request.\n\nProperties\nDYNAMIC_RULESET_ID\nRuleset ID for the dynamic rules added by the extension.\n\nVALUE\n\"_dynamic\"\n\nGETMATCHEDRULES_QUOTA_INTERVAL\nTime interval within which MAX_GETMATCHEDRULES_CALLS_PER_INTERVAL getMatchedRules calls can be made, specified in minutes. Additional calls will fail immediately and set runtime.lastError. Note: getMatchedRules calls associated with a user gesture are exempt from the quota.\n\nVALUE\n10\n\nGUARANTEED_MINIMUM_STATIC_RULES\nChrome 89+\nThe minimum number of static rules guaranteed to an extension across its enabled static rulesets. Any rules above this limit will count towards the global static rule limit.\n\nVALUE\n30000\n\nMAX_GETMATCHEDRULES_CALLS_PER_INTERVAL\nThe number of times getMatchedRules can be called within a period of GETMATCHEDRULES_QUOTA_INTERVAL.\n\nVALUE\n20\n\nMAX_NUMBER_OF_DYNAMIC_RULES\nThe maximum number of dynamic rules that an extension can add.\n\nVALUE\n30000\n\nMAX_NUMBER_OF_ENABLED_STATIC_RULESETS\nChrome 94+\nThe maximum number of static Rulesets an extension can enable at any one time.\n\nVALUE\n50\n\nMAX_NUMBER_OF_REGEX_RULES\nThe maximum number of regular expression rules that an extension can add. This limit is evaluated separately for the set of dynamic rules and those specified in the rule resources file.\n\nVALUE\n1000\n\nMAX_NUMBER_OF_SESSION_RULES\nChrome 120+\nThe maximum number of session scoped rules that an extension can add.\n\nVALUE\n5000\n\nMAX_NUMBER_OF_STATIC_RULESETS\nThe maximum number of static Rulesets an extension can specify as part of the \"rule_resources\" manifest key.\n\nVALUE\n100\n\nMAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES\nChrome 120+\nThe maximum number of \"unsafe\" dynamic rules that an extension can add.\n\nVALUE\n5000\n\nMAX_NUMBER_OF_UNSAFE_SESSION_RULES\nChrome 120+\nThe maximum number of \"unsafe\" session scoped rules that an extension can add.\n\nVALUE\n5000\n\nSESSION_RULESET_ID\nChrome 90+\nRuleset ID for the session-scoped rules added by the extension.\n\nVALUE\n\"_session\"\n\nMethods\ngetAvailableStaticRuleCount()\nPromise Chrome 89+\n\nchrome.declarativeNetRequest.getAvailableStaticRuleCount(\n  callback?: function,\n)\nReturns the number of static rules an extension can enable before the global static rule limit is reached.\n\nPARAMETERS\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(count: number) => void\ncount\nnumber\n\nRETURNS\nPromise<number>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetDisabledRuleIds()\nPromise Chrome 111+\n\nchrome.declarativeNetRequest.getDisabledRuleIds(\n  options: GetDisabledRuleIdsOptions,\n  callback?: function,\n)\nReturns the list of static rules in the given Ruleset that are currently disabled.\n\nPARAMETERS\noptions\nGetDisabledRuleIdsOptions\n\nSpecifies the ruleset to query.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(disabledRuleIds: number[]) => void\ndisabledRuleIds\nnumber[]\n\nRETURNS\nPromise<number[]>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetDynamicRules()\nPromise\n\nchrome.declarativeNetRequest.getDynamicRules(\n  filter?: GetRulesFilter,\n  callback?: function,\n)\nReturns the current set of dynamic rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter.\n\nPARAMETERS\nfilter\nGetRulesFilter optional\n\nChrome 111+\nAn object to filter the list of fetched rules.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(rules: Rule[]) => void\nrules\nRule[]\n\nRETURNS\nPromise<Rule[]>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetEnabledRulesets()\nPromise\n\nchrome.declarativeNetRequest.getEnabledRulesets(\n  callback?: function,\n)\nReturns the ids for the current set of enabled static rulesets.\n\nPARAMETERS\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(rulesetIds: string[]) => void\nrulesetIds\nstring[]\n\nRETURNS\nPromise<string[]>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetMatchedRules()\nPromise\n\nchrome.declarativeNetRequest.getMatchedRules(\n  filter?: MatchedRulesFilter,\n  callback?: function,\n)\nReturns all rules matched for the extension. Callers can optionally filter the list of matched rules by specifying a filter. This method is only available to extensions with the \"declarativeNetRequestFeedback\" permission or having the \"activeTab\" permission granted for the tabId specified in filter. Note: Rules not associated with an active document that were matched more than five minutes ago will not be returned.\n\nPARAMETERS\nfilter\nMatchedRulesFilter optional\n\nAn object to filter the list of matched rules.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(details: RulesMatchedDetails) => void\ndetails\nRulesMatchedDetails\n\nRETURNS\nPromise<RulesMatchedDetails>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ngetSessionRules()\nPromise Chrome 90+\n\nchrome.declarativeNetRequest.getSessionRules(\n  filter?: GetRulesFilter,\n  callback?: function,\n)\nReturns the current set of session scoped rules for the extension. Callers can optionally filter the list of fetched rules by specifying a filter.\n\nPARAMETERS\nfilter\nGetRulesFilter optional\n\nChrome 111+\nAn object to filter the list of fetched rules.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(rules: Rule[]) => void\nrules\nRule[]\n\nRETURNS\nPromise<Rule[]>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nisRegexSupported()\nPromise Chrome 87+\n\nchrome.declarativeNetRequest.isRegexSupported(\n  regexOptions: RegexOptions,\n  callback?: function,\n)\nChecks if the given regular expression will be supported as a regexFilter rule condition.\n\nPARAMETERS\nregexOptions\nRegexOptions\n\nThe regular expression to check.\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(result: IsRegexSupportedResult) => void\nresult\nIsRegexSupportedResult\n\nRETURNS\nPromise<IsRegexSupportedResult>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nsetExtensionActionOptions()\nPromise Chrome 88+\n\nchrome.declarativeNetRequest.setExtensionActionOptions(\n  options: ExtensionActionOptions,\n  callback?: function,\n)\nConfigures if the action count for tabs should be displayed as the extension action's badge text and provides a way for that action count to be incremented.\n\nPARAMETERS\noptions\nExtensionActionOptions\n\ncallback\nfunction optional\n\nChrome 89+\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\ntestMatchOutcome()\nPromise Chrome 103+\n\nchrome.declarativeNetRequest.testMatchOutcome(\n  request: TestMatchRequestDetails,\n  callback?: function,\n)\nChecks if any of the extension's declarativeNetRequest rules would match a hypothetical request. Note: Only available for unpacked extensions as this is only intended to be used during extension development.\n\nPARAMETERS\nrequest\nTestMatchRequestDetails\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n(result: TestMatchOutcomeResult) => void\nresult\nTestMatchOutcomeResult\n\nRETURNS\nPromise<TestMatchOutcomeResult>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nupdateDynamicRules()\nPromise\n\nchrome.declarativeNetRequest.updateDynamicRules(\n  options: UpdateRuleOptions,\n  callback?: function,\n)\nModifies the current set of dynamic rules for the extension. The rules with IDs listed in options.removeRuleIds are first removed, and then the rules given in options.addRules are added. Notes:\n\nThis update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\nThese rules are persisted across browser sessions and across extension updates.\nStatic rules specified as part of the extension package can not be removed using this function.\nMAX_NUMBER_OF_DYNAMIC_RULES is the maximum number of dynamic rules an extension can add. The number of unsafe rules must not exceed MAX_NUMBER_OF_UNSAFE_DYNAMIC_RULES.\nPARAMETERS\noptions\nUpdateRuleOptions\n\nChrome 87+\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nupdateEnabledRulesets()\nPromise\n\nchrome.declarativeNetRequest.updateEnabledRulesets(\n  options: UpdateRulesetOptions,\n  callback?: function,\n)\nUpdates the set of enabled static rulesets for the extension. The rulesets with IDs listed in options.disableRulesetIds are first removed, and then the rulesets listed in options.enableRulesetIds are added. Note that the set of enabled static rulesets is persisted across sessions but not across extension updates, i.e. the rule_resources manifest key will determine the set of enabled static rulesets on each extension update.\n\nPARAMETERS\noptions\nUpdateRulesetOptions\n\nChrome 87+\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nupdateSessionRules()\nPromise Chrome 90+\n\nchrome.declarativeNetRequest.updateSessionRules(\n  options: UpdateRuleOptions,\n  callback?: function,\n)\nModifies the current set of session scoped rules for the extension. The rules with IDs listed in options.removeRuleIds are first removed, and then the rules given in options.addRules are added. Notes:\n\nThis update happens as a single atomic operation: either all specified rules are added and removed, or an error is returned.\nThese rules are not persisted across sessions and are backed in memory.\nMAX_NUMBER_OF_SESSION_RULES is the maximum number of session rules an extension can add.\nPARAMETERS\noptions\nUpdateRuleOptions\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nChrome 91+\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nupdateStaticRules()\nPromise Chrome 111+\n\nchrome.declarativeNetRequest.updateStaticRules(\n  options: UpdateStaticRulesOptions,\n  callback?: function,\n)\nDisables and enables individual static rules in a Ruleset. Changes to rules belonging to a disabled Ruleset will take effect the next time that it becomes enabled.\n\nPARAMETERS\noptions\nUpdateStaticRulesOptions\n\ncallback\nfunction optional\n\nThe callback parameter looks like:\n\n\n() => void\nRETURNS\nPromise<void>\n\nPromises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility. You cannot use both on the same function call. The promise resolves with the same type that is passed to the callback.\n\nEvents\nonRuleMatchedDebug\n\nchrome.declarativeNetRequest.onRuleMatchedDebug.addListener(\n  callback: function,\n)\nFired when a rule is matched with a request. Only available for unpacked extensions with the \"declarativeNetRequestFeedback\" permission as this is intended to be used for debugging purposes only.\n\nPARAMETERS\ncallback\nfunction\n\nThe callback parameter looks like:\n\n\n(info: MatchedRuleInfoDebug) => void\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest"
    ],
    [
      "selection:1732280813065",
      "Selected content from https://developer.chrome.com/docs/extensions/get-started/tutorial/scripts-activetab on 2024-11-22 13:06:53\n\nInject scripts into the active tab \nbookmark_border\nOn this page\n\nOverview\nBefore you start\nBuild the extension\nStep 1: Add the extension data and icons\nStep 2: Initialize the extension\nStep 3: Enable the extension action\nStep 4: Track the state of the current tab\nStep 5: Add or remove the style sheet\n\nSimplify the styling of the current page by clicking the extension toolbar icon.\n\nOverview\nThis tutorial builds an extension that simplifies the styling of the Chrome extension and Chrome Web Store documentation pages so that they are easier to read.\n\nIn this guide, we're going to explain how to do the following:\n\nUse the extension service worker as the event coordinator.\nPreserve user privacy through the \"activeTab\" permission.\nRun code when the user clicks the extension toolbar icon.\nInsert and remove a style sheet using the Scripting API.\nUse a keyboard shortcut to execute code.\nBefore you start\nThis guide assumes that you have basic web development experience. We recommend checking out Hello World for an introduction to the extension development workflow.\n\nBuild the extension\nTo start, create a new directory called focus-mode that will hold the extension's files. If you prefer, you can download the complete source code from GitHub.\n\nStep 1: Add the extension data and icons\nCreate a file called manifest.json and include the following code.\n\n\n{\n  \"manifest_version\": 3,\n  \"name\": \"Focus Mode\",\n  \"description\": \"Enable focus mode on Chrome's official Extensions and Chrome Web Store documentation.\",\n  \"version\": \"1.0\",\n  \"icons\": {\n    \"16\": \"images/icon-16.png\",\n    \"32\": \"images/icon-32.png\",\n    \"48\": \"images/icon-48.png\",\n    \"128\": \"images/icon-128.png\"\n  }\n}\nTo learn more about these manifest keys, check out the \"Run scripts on every tab\" tutorial that explains the extension's metadata and icons in more detail.\n\nCreate an images folder then download the icons into it.\n\nStep 2: Initialize the extension\nExtensions can monitor browser events in the background using the extension's service worker. Service workers are special JavaScript environments that handle events and terminate when they're not needed.\n\nStart by registering the service worker in the manifest.json file:\n\n\n{\n  ...\n  \"background\": {\n    \"service_worker\": \"background.js\"\n  },\n  ...\n}\nCreate a file called background.js and add the following code:\n\n\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.action.setBadgeText({\n    text: \"OFF\",\n  });\n});\nThe first event our service worker will listen for is runtime.onInstalled(). This method allows the extension to set an initial state or complete some tasks on installation. Extensions can use the Storage API and IndexedDB to store the application state. In this case, though, since we're only handling two states, we will use the action's badge text itself to track whether the extension is 'ON' or 'OFF'.\n\nKey term: The action's badge is a colored banner on top of the extension action (toolbar icon).\nStep 3: Enable the extension action\nThe extension action controls the extension's toolbar icon. So whenever the user clicks the extension icon, it will either run some code (like in this example) or display a popup. Add the following code to declare the extension action in the manifest.json file:\n\n\n{\n  ...\n  \"action\": {\n    \"default_icon\": {\n      \"16\": \"images/icon-16.png\",\n      \"32\": \"images/icon-32.png\",\n      \"48\": \"images/icon-48.png\",\n      \"128\": \"images/icon-128.png\"\n    }\n  },\n  ...\n}\nUse the activeTab permission to protect user privacy\nThe activeTab permission grants the extension temporary ability to execute code on the active tab. It also allows access to sensitive properties of the current tab.\n\nThis permission is enabled when the user invokes the extension. In this case, the user invokes the extension by clicking on the extension action.\n\n💡 What other user interactions enable the activeTab permission in my own extension?\n\nPressing a keyboard shortcut combination.\nSelecting a context menu item.\nAccepting a suggestion from the omnibox.\nOpening an extension popup.\nThe \"activeTab\" permission allows users to purposefully choose to run the extension on the focused tab; this way, it protects the user's privacy. Another benefit is that it does not trigger a permission warning.\n\nTo use the \"activeTab\" permission, add it to the manifest's permission array:\n\n\n{\n  ...\n  \"permissions\": [\"activeTab\"],\n  ...\n}\nStep 4: Track the state of the current tab\nAfter the user clicks the extension action, the extension will check if the URL matches a documentation page. Next, it will check the state of the current tab and set the next state. Add the following code to background.js:\n\n\nconst extensions = 'https://developer.chrome.com/docs/extensions';\nconst webstore = 'https://developer.chrome.com/docs/webstore';\n\nchrome.action.onClicked.addListener(async (tab) => {\n  if (tab.url.startsWith(extensions) || tab.url.startsWith(webstore)) {\n    // Retrieve the action badge to check if the extension is 'ON' or 'OFF'\n    const prevState = await chrome.action.getBadgeText({ tabId: tab.id });\n    // Next state will always be the opposite\n    const nextState = prevState === 'ON' ? 'OFF' : 'ON';\n\n    // Set the action badge to the next state\n    await chrome.action.setBadgeText({\n      tabId: tab.id,\n      text: nextState,\n    });\n  }\n});\nStep 5: Add or remove the style sheet\nNow it's time to change the layout of the page. Create a file named focus-mode.css and include the following code:\n\n\n* {\n  display: none !important;\n}\n\nhtml,\nbody,\n*:has(article),\narticle,\narticle * {\n  display: revert !important;\n}\n\n[role='navigation'] {\n  display: none !important;\n}\n\narticle {\n  margin: auto;\n  max-width: 700px;\n}\nInsert or remove the style sheet using the Scripting API. Start by declaring the \"scripting\" permission in the manifest:\n\n\n{\n  ...\n  \"permissions\": [\"activeTab\", \"scripting\"],\n  ...\n}\nSuccess: The Scripting API does not trigger a permission warning.\nFinally, in background.js add the following code to change the layout of the page:\n\n\n  ...\n    if (nextState === \"ON\") {\n      // Insert the CSS file when the user turns the extension on\n      await chrome.scripting.insertCSS({\n        files: [\"focus-mode.css\"],\n        target: { tabId: tab.id },\n      });\n    } else if (nextState === \"OFF\") {\n      // Remove the CSS file when the user turns the extension off\n      await chrome.scripting.removeCSS({\n        files: [\"focus-mode.css\"],\n        target: { tabId: tab.id },\n      });\n    }\n  }\n});\n💡 Can I use the Scripting API to inject code instead of a style sheet?\n\nYes. You can use scripting.executeScript() to inject JavaScript.\n\nOptional: Assign a keyboard shortcut\nJust for fun, add a shortcut to make it easier to enable or disable focus mode. Add the \"commands\" key to the manifest.\n\n\n{\n  ...\n  \"commands\": {\n    \"_execute_action\": {\n      \"suggested_key\": {\n        \"default\": \"Ctrl+B\",\n        \"mac\": \"Command+B\"\n      }\n    }\n  }\n}\nThe \"_execute_action\" key runs the same code as the action.onClicked() event, so no additional code is needed.\n\nTest that it works\nVerify that the file structure of your project looks like the following:\n\n\n\nLoad your extension locally\nTo load an unpacked extension in developer mode, follow the steps in Hello World.\n\nTest the extension on a documentation page\nFirst, open any of the following pages:\n\nWelcome to the Chrome Extension documentation\nPublish in the Chrome Web Store\nScripting API\nThen, click the extension action. If you set up a keyboard shortcut, you can test it by pressing Ctrl + B or Cmd + B.\n\nIt should go from this:\n\n\nFocus Mode extension off\nTo this:\n\n\nFocus Mode extension on\n🎯 Potential enhancements\nBased on what you've learned today, try to accomplish any of the following:\n\nImprove the CSS style sheet.\nAssign a different keyboard shortcut.\nChange the layout of your favorite blog or documentation site.\nKeep building.\nCongratulations on finishing this tutorial 🎉. Continue leveling up your skills by completing other tutorials on this series:\n\nExtension\tWhat you will learn\nReading time\tTo insert an element on a specific set of pages automatically.\nTabs Manager\tTo create a popup that manages browser tabs.\n\nEnd of selected content from https://developer.chrome.com/docs/extensions/get-started/tutorial/scripts-activetab"
    ]
  ],
  "selectionOrder": [
    "selection:1732280598504",
    "selection:1732280608852",
    "selection:1732280623301",
    "selection:1732280645719",
    "selection:1732280682349",
    "selection:1732280701383",
    "selection:1732280744188",
    "selection:1732280813065"
  ]
}