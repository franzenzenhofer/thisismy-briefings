{
  "selectedFiles": [
    [
      "/interdimensional-chimney/game.js",
      {
        "filePath": "/interdimensional-chimney/game.js",
        "name": "game.js",
        "type": "text/javascript"
      }
    ],
    [
      "/interdimensional-chimney/index.html",
      {
        "filePath": "/interdimensional-chimney/index.html",
        "name": "index.html",
        "type": "text/html"
      }
    ],
    [
      "/interdimensional-chimney/LICENSE",
      {
        "filePath": "/interdimensional-chimney/LICENSE",
        "name": "LICENSE",
        "type": ""
      }
    ],
    [
      "/interdimensional-chimney/styles.css",
      {
        "filePath": "/interdimensional-chimney/styles.css",
        "name": "styles.css",
        "type": "text/css"
      }
    ],
    [
      "/interdimensional-chimney/CNAME",
      {
        "filePath": "/interdimensional-chimney/CNAME",
        "name": "CNAME",
        "type": ""
      }
    ],
    [
      "/interdimensional-chimney/game.html",
      {
        "filePath": "/interdimensional-chimney/game.html",
        "name": "game.html",
        "type": "text/html"
      }
    ]
  ],
  "selectedURLs": [],
  "selectedNotes": [
    [
      "note:1731499135226",
      "To build a responsive, emoji-based HTML5 game with no dependencies that works seamlessly on both mobile and desktop, you‚Äôll want to follow a set of best practices focused on responsive design, touch-and-keyboard input handling, dynamic scaling, and performance optimization. Here‚Äôs a detailed guide on the general approach:  ---  ## 1. Concept and Design Planning  **Goal**: Design a simple and accessible game using emojis as visual elements. Emojis are lightweight, widely supported, and offer a consistent experience across devices.  - **Platform Accessibility**: Ensure the game works across mobile and desktop devices. This includes touch and keyboard support, responsive layout adjustments, and optimized display for various screen sizes. - **Responsiveness**: Design the layout so it scales proportionally to fit any screen size without relying on browser zooming or page scaling. - **Single Page Application**: Use a single HTML file or minimal HTML files to keep the game lightweight and responsive. - **No External Dependencies**: Avoid external libraries (e.g., jQuery) to ensure the game is self-contained, loads quickly, and has minimal performance overhead.  ---  ## 2. Set Up the Basic HTML Structure  Create a minimal HTML structure with semantic elements for a clean and responsive layout.  ### Basic HTML Layout  - **Use `meta` tags** to control scaling and make the game responsive:   ```html   <!DOCTYPE html>   <html lang=\"en\">   <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no\">     <title>Emoji Game</title>     <style>       /* Basic styling here */     </style>   </head>   <body>     <div id=\"game\"></div>     <script src=\"game.js\"></script>   </body>   </html>   ```  - **Viewport meta tag** ensures the game fills the screen without allowing users to zoom, which keeps the game‚Äôs design fixed. - **Flexible layout container** (`div#game`) will dynamically scale and hold the game's grid.  ---  ## 3. Responsive Design and Dynamic Sizing with CSS and JavaScript  Design the game layout to adapt to different screen sizes by calculating the optimal number of rows and columns based on the screen‚Äôs width and height.  ### Dynamic Sizing and Font Adjustment  - **CSS Styling**: Apply basic, mobile-first styling and override it with media queries for larger screens.   ```css   body, html {     margin: 0;     padding: 0;     overflow: hidden;     display: flex;     justify-content: center;     align-items: center;     height: 100vh;     font-family: 'Arial', sans-serif;   }    #game {     display: grid;     gap: 2px;     font-size: calc(100vw / 20); /* Adjust font size based on viewport */   }   ```  - **JavaScript for Dynamic Layout**: Use JavaScript to determine the grid size and cell dimensions based on the screen size. Calculate the number of rows and columns dynamically:   ```javascript   function calculateGridSize() {     const gameElement = document.getElementById('game');     const screenWidth = window.innerWidth;     const screenHeight = window.innerHeight;     const cellSize = Math.min(screenWidth, screenHeight) / 20;     gameElement.style.fontSize = `${cellSize}px`;      // Calculate rows and columns for the grid     const rows = Math.floor(screenHeight / cellSize);     const cols = Math.floor(screenWidth / cellSize);     createGameGrid(rows, cols);   }   ```  - **Resize Event Listener**: Add an event listener to recalculate the grid if the screen is resized, ensuring responsiveness.   ```javascript   window.addEventListener('resize', calculateGridSize);   ```  ---  ## 4. Emoji-Based Game Elements  Use emojis to represent game elements (player, obstacles, rewards) to avoid the need for graphic assets.  ### Define Emoji Elements in JavaScript  - **Emoji Map**: Create an object to store emojis for each game element.   ```javascript   const symbols = {     player: 'üïπÔ∏è',     treasure: 'üíé',     wall: 'üß±',     empty: '‚¨ú'   };   ```  - **Game Grid Creation**: Initialize the grid as a 2D array, filling it with `empty` emojis by default and adding other elements like `player`, `treasure`, or `wall` as needed.   ```javascript   function createGameGrid(rows, cols) {     const grid = Array.from({ length: rows }, () => Array(cols).fill(symbols.empty));     // Place other elements (e.g., player, treasure)     grid[0][0] = symbols.player;     displayGrid(grid);   }   ```  ---  ## 5. Input Handling for Both Mobile and Desktop  Support both keyboard input (for desktop) and touch input (for mobile). This ensures the game is playable across all devices without external dependencies.  ### Keyboard Controls  - **Arrow Key Handling**: Use `keydown` events for desktop keyboard input.   ```javascript   window.addEventListener('keydown', (event) => {     const direction = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right' }[event.key];     if (direction) movePlayer(direction);   });   ```  ### Touch Controls for Mobile  - **Touch Input for Swiping**: Use touchstart and touchmove events to detect swipes.   ```javascript   let touchStartX = 0, touchStartY = 0;    gameElement.addEventListener('touchstart', (e) => {     const touch = e.touches[0];     touchStartX = touch.clientX;     touchStartY = touch.clientY;   });    gameElement.addEventListener('touchmove', (e) => {     const touch = e.touches[0];     const dx = touch.clientX - touchStartX;     const dy = touch.clientY - touchStartY;      if (Math.abs(dx) > Math.abs(dy)) {       movePlayer(dx > 0 ? 'right' : 'left');     } else {       movePlayer(dy > 0 ? 'down' : 'up');     }   });   ```  ---  ## 6. Game Loop and State Management  Set up a simple game loop to update the game state (player position, score, etc.) and re-render the grid regularly.  ### Game State Object  Define a game state object to store information such as player position, score, and current grid layout. ```javascript const gameState = {   playerPosition: { row: 0, col: 0 },   score: 0,   grid: [] }; ```  ### Game Loop with `setInterval`  Use a game loop to handle periodic updates (such as movement and animation) without relying on any external libraries. ```javascript function startGameLoop() {   setInterval(() => {     updateGameState();     renderGame();   }, 100); // Adjust interval as needed } ```  ---  ## 7. Rendering and Display  Render the grid dynamically, updating only the cells that change to minimize performance overhead.  ### Grid Rendering  - **Initial Display**: Render the entire grid initially by generating HTML elements for each cell. - **Efficient Updates**: For each frame, only update cells that have changed.   ```javascript   function renderGame() {     const gameElement = document.getElementById('game');     gameElement.innerHTML = gameState.grid.map(row => row.map(cell => `<span>${cell}</span>`).join('')).join('<br>');   }   ```  ### Responsiveness for Different Devices  Keep text size and layout proportionate to the screen using CSS and JavaScript to calculate an appropriate font size.  ---  ## 8. Handling Scaling and Performance  Keep the game performant by minimizing DOM manipulation and using efficient methods to handle game logic.  ### Performance Tips  - **Avoid frequent DOM updates**: Update only parts of the game that have changed. - **Use requestAnimationFrame for Animations**: For smooth animations, use `requestAnimationFrame`. - **Optimize Grid Layout**: Use CSS Grid or Flexbox for layout flexibility. - **Event Throttling**: Limit the rate of input handling to prevent performance issues on mobile.  ---  ## 9. CSS Styles for Mobile-First Design  Keep CSS simple and mobile-first. Avoid complex styling and animations that can slow down the game on mobile devices.  ### Basic CSS Example  ```css #game {   display: grid;   grid-template-columns: repeat(auto-fit, minmax(24px, 1fr));   gap: 2px; }  span {   display: inline-block;   width: 100%;   text-align: center; } ```  ---  ## 10. Testing and Final Adjustments  ### Cross-Device Testing  Test the game on various devices and screen orientations to ensure it scales properly and controls are responsive. Use Chrome DevTools or a similar tool to emulate different devices.  ### Accessibility Considerations  Ensure elements have sufficient color contrast and are readable. You can use ARIA labels if text-to-speech support is required.  ---  ## Summary  By following this framework, you can create a responsive, emoji-based HTML5 game that works well across devices and is easily maintainable. This setup prioritizes simplicity, responsiveness, and performance, making it a robust choice for developing lightweight, interactive games."
    ]
  ],
  "selectedSpecials": [],
  "outputContents": [
    [
      "/interdimensional-chimney/game.js",
      "This is my current /interdimensional-chimney/game.js on 2024-11-13 11:54:28\n\nconst symbols = {\n    dirt: 'üü©',\n    diamond: 'üéÅ', // Gift box for diamond\n    rock: 'üåü', // Snowman for rock\n    empty: '‚¨õÔ∏è',\n    wall: 'üß±', // Christmas tree for wall\n    exit: 'üéÑ', // Door for exit\n    worker: 'üéÖ', // Santa Claus for worker\n    xx: 'üëª',\n    water: \"‚ùÑÔ∏è\", // Snowflake for water\n    dynamite: \"üí£\", // Bomb for dynamite (no Christmas equivalent)\n    explosion: \"üí•\",\n    barrier: \"‚õÑÔ∏è\", // Reindeer for barrier\n    magic: \"‚ú®\"\n};\n\n// Add a steps property to the player object\nlet player = {\n    row: 0,\n    col: 0,\n    thisLevelDiamonds: 0,\n    totalDiamonds: 0, // Total diamonds collected across all levels\n    action: null,\n    isCrushed: false,\n    steps: 0,\n    initialPosition: { row: 0, col: 0 },\n    dynamite: 3\n};\n\nconst backupPlayer = {...player};\n\nconst level_state = {\n    start_the_water: 100,\n    dynamites: [],\n    water_every_x_round: 3,\n    currentLevel: 1,\n    diamondPercentageThreshold: 0.19,\n    barriersChangedToMagic: false\n};\n\nconst level_state_backup = {...level_state};\n\nconst configuration =\n{\n\n}\n\nlet previousMaze = [];\nlet gameLoop;\nlet is_finish = false;\nlet totalDiamonds = 0;\nlet stuck = 0;\nlet dirtAdjacentPositions = [];\n\n// Mapping object for arrow keys and their corresponding actions\nconst keyActionMap = {\n    'ArrowUp': 'up',\n    'ArrowDown': 'down',\n    'ArrowLeft': 'left',\n    'ArrowRight': 'right',\n    ' ': 'space'\n};\n\n// Get the maze element\nconst mazeElement = document.getElementById('maze');\n\n        // Utility function to create a grid of a given size and fill it with a specific value\n        const createGrid = (cols, rows, fillValue) => Array.from({ length: rows }, () => Array(cols).fill(fillValue));\n\n        const performRandomAction = (maze, count, checkFn, actionFn) => {\n            let newMaze = maze.map(row => [...row]);\n            while (count > 0) {\n                let r = Math.floor(Math.random() * newMaze.length);\n                let c = Math.floor(Math.random() * newMaze[0].length);\n                if (checkFn(newMaze, r, c)) {\n                    actionFn(newMaze, r, c);\n                    count--;\n                }\n            }\n            return newMaze;\n        };\n\n        const placeRandomItems = (maze, item, count) => {\n            return performRandomAction(\n                maze,\n                count,\n                (maze, r, c) => maze[r][c] === symbols.dirt,\n                (maze, r, c) => { maze[r][c] = item; }\n            );\n        };\n\n        const createRoom = (maze, rows, cols, roomSize = Math.floor(Math.random() * 4) + 10, startRow = Math.floor(Math.random() * rows), startCol = Math.floor(Math.random() * cols), what = symbols.wall) => {\n\n            // Create the room\n            for (let i = startRow; i < startRow + roomSize; i++) {\n                for (let j = startCol; j < startCol + roomSize; j++) {\n                    // Check if the cell is within the maze boundaries\n                    if (i >= 0 && i < rows && j >= 0 && j < cols) {\n                        // Check if the cell is on the edge of the room\n                        if (i === startRow || i === startRow + roomSize - 1 || j === startCol || j === startCol + roomSize - 1) {\n                            // Set the cell to be a wall\n                            maze[i][j] = what;\n                        } else {\n                            // Set the cell to be dirt\n                            maze[i][j] = symbols.dirt;\n                        }\n                    }\n                }\n            }\n\n            return maze;\n        };\n\n        const replaceWallsWithDirt = (maze, rows, cols) => {\n            for (let i = 0; i < rows; i++) {\n                for (let j = 0; j < cols; j++) {\n                    // Check if the cell is a wall\n                    if (maze[i][j] === symbols.wall) {\n                        // Randomly decide whether to replace the wall with dirt\n                        if (Math.random() < 0.5) {\n                            maze[i][j] = symbols.dirt;\n                        }\n                    }\n                }\n            }\n        \n            return maze;\n        };\n\n        const mazeMaker = (cols, rows, diamonds, rocks, empties, walls, number_of_rooms = 10) => {\n\n\n            let maze = createGrid(cols, rows, symbols.dirt);\n\n            // Create multiple rooms in the maze\n            for (let i = 0; i < number_of_rooms; i++) {\n                maze = createRoom(maze, rows, cols);\n            }\n\n            // Replace 50% of all walls with dirt\n            maze = replaceWallsWithDirt(maze, rows, cols);\n\n\n                       // Count the number of walls in the maze\n                       let wallCount = maze.flat().filter(cell => cell === symbols.wall).length;\n\n                       // If the number of walls is less than the specified number of walls, add the missing walls randomly\n                       if (wallCount < walls) {\n                           maze = placeRandomItems(maze, symbols.wall, walls - wallCount);\n                       }\n           \n\n            // Create a random-ish path from (0, 0) to the exit\n            let r = 0, c = 0;\n            while (r < rows - 1 || c < cols - 1) {\n                maze[r][c] = symbols.dirt;\n                if (Math.random() < 0.5) {\n                    if (r < rows - 1) r++;\n                } else {\n                    if (c < cols - 1) c++;\n                }\n            }\n\n            // Place diamonds, rocks, and empties in the maze\n            [[symbols.diamond, diamonds], [symbols.rock, rocks], [symbols.empty, empties]].forEach(([item, count]) => {\n                maze = placeRandomItems(maze, item, count);\n            });\n\n \n            // Set the worker and the exit\n            maze[0][0] = symbols.worker;\n            maze[rows - 1][cols - 1] = symbols.exit;\n\n            // Add barriers around the exit\n            for (let i = rows - 2; i <= rows; i++) {\n                for (let j = cols - 2; j <= cols; j++) {\n                    // Check if the cell is within the maze boundaries and is not the exit\n                    if (i >= 0 && i < rows && j >= 0 && j < cols && !(i === rows - 1 && j === cols - 1)) {\n                        // Check if the cell is not already a barrier\n                        if (!isBarrier(maze, i, j)) {\n                            // Set the cell to be a barrier\n                            maze = setBarrier(maze, i, j);\n                        }\n                    }\n                }\n            }\n\n            return maze;\n        };\n\n        const mazeMakerByPercentages = (cols, rows, diamondPercentage, rockPercentage, emptyPercentage, wallPercentage) => {\n            const totalCells = cols * rows;\n    \n            const diamonds = Math.floor(totalCells * diamondPercentage / 100);\n            const rocks = Math.floor(totalCells * rockPercentage / 100);\n            const empties = Math.floor(totalCells * emptyPercentage / 100);\n            const walls = Math.floor(totalCells * wallPercentage / 100);\n    \n            return mazeMaker(cols, rows, diamonds, rocks, empties, walls);\n        };\n\n\n\n        // Function to check if the worker can reach the exit from a given position\n        const canReachExit = (maze, r = 0, c = 0, visited = new Set()) => {\n            //return true;\n            const rows = maze.length;\n            const cols = maze[0].length;\n            const pos = r * cols + c;\n\n            // If the current position is out of bounds, has been visited before, or is a rock or wall, return false\n            if (r < 0 || r >= rows || c < 0 || c >= cols || visited.has(pos) || maze[r][c] === symbols.rock || maze[r][c] === symbols.wall) {\n                return false;\n            }\n            // If the current position is the exit, return true\n            if (maze[r][c] === symbols.exit) {\n                return true;\n            }\n\n            // Mark the current position as visited\n            visited.add(pos);\n\n            // Check all four directions (right, down, left, up)\n            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n            return directions.some(([dr, dc]) => canReachExit(maze, r + dr, c + dc, visited));\n        };\n\n\n        function safeGet(maze, row, col, defaultValue = symbols.wall) {\n            const cellType = getCellType(maze, row, col);\n            return cellType !== false ? cellType : defaultValue;\n        }\n        \n        const isAffectedByGravity = (maze, r, c) => {\n            const cell = safeGet(maze, r, c, symbols.wall);\n            return cell === symbols.rock || cell === symbols.diamond;\n        };\n\n                // Helper function to loop over the maze and perform actions based on a check function\n                const loopOverMaze = (maze, checkFn, actionFn, elseFn) => {\n                    let newMaze = maze.map(row => [...row]);\n                    for (let r = 0; r < maze.length; r++) {\n                        for (let c = 0; c < maze[0].length; c++) {\n                            if (checkFn(maze, r, c)) {\n                                actionFn(newMaze, r, c);\n                            } else if (elseFn) {\n                                elseFn(newMaze, r, c);\n                            }\n                        }\n                    }\n                    return newMaze;\n                };\n\n\nconst canSlip = (maze, row, col) => {\n    const isCurrentElementMovable = isAffectedByGravity(maze, row, col);\n    const isBelowElementMovable = isAffectedByGravity(maze, row + 1, col);\n\n    const canSlipLeft = safeGet(maze, row, col - 1, symbols.wall) === symbols.empty && safeGet(maze, row + 1, col - 1, symbols.wall) === symbols.empty;\n    const canSlipRight = safeGet(maze, row, col + 1, symbols.wall) === symbols.empty && safeGet(maze, row + 1, col + 1, symbols.wall) === symbols.empty;\n\n    const canSlip = isCurrentElementMovable && isBelowElementMovable && (canSlipLeft || canSlipRight);\n\n    return canSlip;\n};\n\n\n\n// Helper function to perform the slip action\nconst doSlip = (maze, r, c) => {\n    const shouldSlipLeft = maze[r][c - 1] === symbols.empty && maze[r + 1][c - 1] === symbols.empty;\n    const shouldSlipRight = maze[r][c + 1] === symbols.empty && maze[r + 1][c + 1] === symbols.empty;\n    \n    if (shouldSlipLeft && shouldSlipRight) {\n      if (Math.random() < 0.5) {\n        maze[r][c - 1] = maze[r][c]; // Slip left\n      } else {\n        maze[r][c + 1] = maze[r][c]; // Slip right\n      }\n    } else if (shouldSlipLeft) {\n      maze[r][c - 1] = maze[r][c]; // Slip left\n    } else if (shouldSlipRight) {\n      maze[r][c + 1] = maze[r][c]; // Slip right\n    }\n    maze[r][c] = symbols.empty; // Clear the original position\n};\n\nconst applySlipOrGravity = (maze) => {\n    // Create a copy of the original maze\n    let oldMaze = maze.map(row => [...row]);\n\n    // Apply gravity and get the new maze\n    let newMaze = applyGravity(maze);\n\n    // Get a data structure that compares the old and the new maze and saves the position of the changes\n    let changedPositions = [];\n    for (let r = 0; r < oldMaze.length; r++) {\n        for (let c = 0; c < oldMaze[0].length; c++) {\n            if (oldMaze[r][c] !== newMaze[r][c]) {\n                changedPositions.push({ r, c });\n            }\n        }\n    }\n\n    // Apply slip to the new maze, but only for positions where gravity has not caused an element to fall\n    newMaze = loopOverMaze(newMaze, (maze, r, c) => canSlip(maze, r, c) && !changedPositions.some(pos => pos.r === r && pos.c === c), doSlip);\n\n    return newMaze;\n};\n// Function to apply the \"slip\" rule to the maze\nconst applySlip = (maze) => {\n    return loopOverMaze(maze, canSlip, doSlip);\n};\n  \n\n        const applyGravity = (maze) => {\n            return loopOverMaze(\n                maze,\n                // Check if the current element is affected by gravity and the space below is empty\n                (maze, r, c) => isAffectedByGravity(maze, r, c) && safeGet(maze, r + 1, c, symbols.wall) === symbols.empty,\n                // If the check passes, move the current element down\n                (newMaze, r, c) => {\n                    if (safeGet(newMaze, r + 1, c, symbols.wall) !== symbols.wall) {\n                        newMaze[r + 1][c] = newMaze[r][c];\n                        newMaze[r][c] = symbols.empty;\n                    }\n                }\n            );\n        };\n\n        const isWBounds = (maze, r, c) => {\n            return r >= 0 && r < maze.length && c >= 0 && c < maze[0].length;\n        };\n        \n\n\n\n        // Function to check if the player is under a falling element\n        const isUnderFallingElement = (maze, previousMaze, player_r, player_c) => {\n            // Calculate the position of the cell above the player\n            const moveable_r = player_r - 1;\n            const moveable_c = player_c;\n\n            // Check if the cell above the player is within the maze boundaries\n            // If it's not, return false because the player can't be under a falling element outside the maze\n            if(!isWBounds(maze, moveable_r, moveable_c)) {\n                return false;\n            }\n\n            // Check if the cell above the player contains an element that is affected by gravity (i.e., a rock or a diamond)\n            // If it doesn't, return false because the player can't be under a falling element that isn't affected by gravity\n            if(!isAffectedByGravity(maze, moveable_r, moveable_c)) {\n                return false;\n            }\n            \n            // Check if the cell above the player was empty or contained the player in the previous state of the maze\n            // If it was, it means the element in the cell above the player has fallen\n            const hasFallen = ((previousMaze[moveable_r][moveable_c] === symbols.empty) || (previousMaze[moveable_r][moveable_c]  === symbols.worker));\n\n            // Return true if the element in the cell above the player has fallen, false otherwise\n            return hasFallen;\n        };\n\n        \n        const getDiamondRatio = (playerDiamonds, totalDiamonds) => {\n            return totalDiamonds === 0 ? 0 : playerDiamonds / totalDiamonds;\n        }\n\n        const getDiamondPercentage = (playerDiamonds, totalDiamonds) => {\n            if (playerDiamonds === totalDiamonds) {\n                return 100;\n            }\n            return Math.floor(getDiamondRatio(playerDiamonds, totalDiamonds) * 100);\n        }\n\n      \n        let comparisonMaze = null;\n\n        const updateGameInfo = () => {\n            const levelElement = document.getElementById('level');\n            const diamondsElement = document.getElementById('diamonds');\n\n            // Calculate the percentage of diamonds collected by the player\n            const diamondPercentage = getDiamondPercentage(player.thisLevelDiamonds, totalDiamonds);\n            levelElement.innerText = `üè†${level_state.currentLevel}`;\n            let spaces = diamondPercentage < 10 ? \"&nbsp;&nbsp;\" : diamondPercentage < 100 ? \"&nbsp;\" : \"\";\n            diamondsElement.innerHTML = `${spaces}${diamondPercentage}%üéÅ`;\n\n            // If diamondPercentage is above the threshold, add the 'greentext' class to diamondsElement\n            if (getDiamondRatio(player.thisLevelDiamonds, totalDiamonds) >= level_state.diamondPercentageThreshold) {\n                diamondsElement.classList.add('greentext');\n            } else {\n                diamondsElement.classList.remove('greentext');\n            }\n        }\n\n        const displayMaze = (maze) => {\n            const mazeElement = document.getElementById('maze');\n\n            if (player.isCrushed) {\n                maze[player.row][player.col] = symbols.xx;\n            }\n\n            // If comparisonMaze is null, initialize it to be a deep copy of the current maze and create the DOM elements for all cells\n            if (!comparisonMaze) {\n                comparisonMaze = maze.map(row => [...row]);\n                mazeElement.innerHTML = '<table>' + maze.map((row, rowIndex) => '<tr>' + row.map((cell, colIndex) => `<td id=\"cell-r${rowIndex}-c${colIndex}\" class=\"${cell}\">${cell}</td>`).join('') + '</tr>').join('') + '</table>';\n            }\n\n            any_change = false;\n            // Iterate over the current maze and the comparisonMaze\n            for (let rowIndex = 0; rowIndex < maze.length; rowIndex++) {\n                for (let colIndex = 0; colIndex < maze[0].length; colIndex++) {\n                    // If a cell in the current maze is not the same as the corresponding cell in comparisonMaze, this cell has changed\n                    if (maze[rowIndex][colIndex] !== comparisonMaze[rowIndex][colIndex]) {\n                        // Find the corresponding DOM element using its unique ID and update its class and text content\n                        const cellElement = document.getElementById(`cell-r${rowIndex}-c${colIndex}`);\n                        cellElement.className = maze[rowIndex][colIndex];\n                        cellElement.innerText = maze[rowIndex][colIndex];\n                        any_change = true;\n                    }\n                }\n            }\n\n            if(any_change)  {\n                updateGameInfo();\n            }\n\n            // After rendering the current maze, update comparisonMaze to be a deep copy of the current maze\n            comparisonMaze = maze.map(row => [...row]);\n        };\n\n\n            function calculateRowsCols() {\n                const screenWidth = window.innerWidth;\n                const screenHeight = window.innerHeight - document.querySelector('.info').offsetHeight; // Adjust for the info section\n\n                // Create a temporary span to measure the character size\n                const measureSpan = document.createElement('span');\n                measureSpan.style.visibility = 'hidden';\n                measureSpan.innerText = symbols.dirt; // Use a character from your maze\n                document.body.appendChild(measureSpan);\n\n                // Measure the character\n                let charWidth = measureSpan.offsetWidth;\n                let charHeight = measureSpan.offsetHeight;\n\n                // Remove the temporary span from the document\n                document.body.removeChild(measureSpan);\n\n                // Ensure the minimum size is 20 pixels for mobile screens and 28 pixels for larger screens\n                const minSize = screenWidth <= 768 ? 24 : 24; // 768px is a common breakpoint for mobile screens\n                charWidth = Math.max(charWidth, minSize);\n                charHeight = Math.max(charHeight, minSize);\n\n                    // Create a style element\n    const style = document.createElement('style');\n    style.innerHTML = `\n        .maze td {\n            width: ${charWidth}px;\n            height: ${charHeight}px;\n        }\n    `;\n\n    // Append the style element to the head of the document\n    document.head.appendChild(style);\n\n                // Calculate the number of columns and rows based on the character size\n                let cols = Math.floor(screenWidth / charWidth);\n                let rows = Math.floor(screenHeight / charHeight);\n\n                // Adjust the number of columns and rows if necessary to ensure that the maze fits within the viewport\n                if (cols * charWidth > (screenWidth*0.95)) {\n                    cols--;\n                }\n                if (rows * charHeight > screenHeight) {\n                    rows--;\n                }\n     \n\n                return { cols, rows };\n            }\n          \n   \n\n\n        // Function to calculate the optimal font size for the maze\n        const calculateFontSize = (maze, maxMazeWidth, maxMazeHeight) => {\n            // Calculate the size of the emoji based on the maze size and viewport size\n            const emojiSizeWidth = maxMazeWidth / maze[0].length;\n            const emojiSizeHeight = maxMazeHeight / maze.length;\n            return Math.min(emojiSizeWidth, emojiSizeHeight);\n        };\n\n        // Function to set the font size of the maze element\n        const setMazeFontSize = (mazeElement, fontSize) => {\n            mazeElement.style.fontSize = `${fontSize}px`;\n        };\n\n        // Function to resize the maze\n        const resizeMaze = (maze, mazeElement) => {\n            const maxMazeWidth = window.innerWidth - 20; // Margin consideration\n            const maxMazeHeight = window.innerHeight - 20 - document.querySelector('.info').offsetHeight; // Adjust for the info section\n            //set info to vislibity not hidden\n            document.querySelector('.info').style.visibility = 'visible';\n            const fontSize = calculateFontSize(maze, maxMazeWidth, maxMazeHeight);\n            setMazeFontSize(mazeElement, fontSize);\n        };\n\n\n\nconst updatePosition = (row, col, direction, debug = false) => {\n    const directions = {\n        'up':    { newRow: row - 1, newCol: col },\n        'down':  { newRow: row + 1, newCol: col },\n        'left':  { newRow: row, newCol: col - 1 },\n        'right': { newRow: row, newCol: col + 1 },\n        'none':  { newRow: row, newCol: col }\n    };\n\n    if(debug) {\n        console.log(\"in updatePosition\");\n        console.log(\"row\", row);\n        console.log(\"col\", col);\n        console.log(\"direction\", direction);\n    }\n\n    if (!directions[direction]) {\n        console.error(`Invalid direction: ${direction}`);\n        return { newRow: row, newCol: col };\n    }\n\n    return directions[direction];\n};\n\nconst updatePostionAsArray = (row, col, direction) => {\n   const  { newRow, newCol } =  updatePosition(row, col, direction);\n   return [newRow, newCol];\n};\n\n// Function to check if a cell is of a certain type\nconst isCellType = (maze, row, col, type) => {\n    return row >= 0 && row < maze.length && col >= 0 && col < maze[0].length && maze[row][col] === symbols[type];\n};\n\nconst getCellType = (maze, row, col) => {\n    if (row < 0 || row >= maze.length || col < 0 || col >= maze[0].length) {\n        return false;  // or any default value\n    }\n    return maze[row][col];\n}\n\nconst setCellType = (maze, row, col, type) => {\n    if (row < 0 || row >= maze.length || col < 0 || col >= maze[0].length) {\n        return false;  // or any default value\n    }\n    maze[row][col] = type;\n    return maze;\n}\n\nconst setDynamite = (maze, row, col) => {\n    // If not the player is on the same field\n    if (row === player.row && col === player.col) {\n        return maze;\n    }\n\n    return setCellType(maze, row, col, symbols.dynamite);\n}\n\nconst updateDynamiteCount = (n) => {\n    // Gray out a dynamite icon\n    if (n > 0) {\n        document.getElementById(`dynamite-${n}`).classList.add('grayed-out');\n    }\n}\n\nconst resetDynamiteCount = () => {\n    // Reset the dynamite icons \n    for (let i = 1; i <= 3; i++) {\n        document.getElementById(`dynamite-${i}`).classList.remove('grayed-out');\n    }\n}\n\nconst setExplosion = (maze, row, col) => {\n    if (!isExit(maze, row, col) && !isBarrier(maze, row, col)) {\n        return setCellType(maze, row, col, symbols.explosion);\n    }\n    return maze;\n}\n\nconst setDirt = (maze, row, col) => {\n    return setCellType(maze, row, col, symbols.dirt);\n}\n\nconst changeBarrierToMagic = (maze) => {\n    return loopOverMaze(maze, isBarrier, setMagic); \n}\n\nconst changeMagicToDirt = (maze) => {\n    return loopOverMaze(maze, isMagic, setDirt);\n}\n\nconst setEmpty = (maze, row, col) => {\n    return setCellType(maze, row, col, symbols.empty);\n}\n\n// Check functions\nconst isWall = (maze, row, col) => isCellType(maze, row, col, 'wall');\nconst isExit = (maze, row, col) => isCellType(maze, row, col, 'exit');\nconst isRock = (maze, row, col) => isCellType(maze, row, col, 'rock');\nconst isDiamond = (maze, row, col) => isCellType(maze, row, col, 'diamond');\nconst isEmpty = (maze, row, col) => isCellType(maze, row, col, 'empty');\nconst isWater = (maze, row, col) => isCellType(maze, row, col, 'water');\nconst isPlayer = (maze, row, col) => isCellType(maze, row, col, 'worker');\nconst isDirt = (maze, row, col) => isCellType(maze, row, col, 'dirt');\nconst isDynamite = (maze, row, col) => isCellType(maze, row, col, 'dynamite');\nconst isExplosion = (maze, row, col) => isCellType(maze, row, col, 'explosion');\nconst isEmptyOrPlayer = (maze, row, col) => isEmpty(maze, row, col) || isPlayer(maze, row, col);\n// Check functions\nconst isMagic = (maze, row, col) => isCellType(maze, row, col, 'magic');\nconst isBarrier = (maze, row, col) => isCellType(maze, row, col, 'barrier');\n\n// Set functions\nconst setMagic = (maze, row, col) => setCellType(maze, row, col, symbols.magic);\nconst setBarrier = (maze, row, col) => setCellType(maze, row, col, symbols.barrier);\n\nconst isAdjacentToPlayer = (player, elementRow, elementCol) => {\n    const rowDifference = Math.abs(player.row - elementRow);\n    const colDifference = Math.abs(player.col - elementCol);\n\n    // An element is adjacent to the player if it's in a cell directly next to the player's cell,\n    // i.e., the row difference is 1 and the column difference is 0, or vice versa.\n    return (rowDifference === 1 && colDifference === 0) || (rowDifference === 0 && colDifference === 1);\n};\n\n// Function to check if the new position is within the maze and not a wall\nconst isValidMove = (maze, newRow, newCol) => {\n    return newRow >= 0 && newRow < maze.length && newCol >= 0 && newCol < maze[0].length && !isWall(maze, newRow, newCol);\n};\n// Function to check if the player can push the rock and move to the new position\nconst canPushAndMove = (maze, row, col, direction) => {\n    // If the direction is 'up' or 'down', return false\n    if (direction === 'up' || direction === 'down') {\n        return false;\n    }\n\n    const { newRow, newCol } = updatePosition(row, col, direction);\n    const [nextRow, nextCol] = updatePostionAsArray(newRow, newCol, direction, false);\n\n    const canMove = isRock(maze, newRow, newCol) && isEmpty(maze, nextRow, nextCol);\n\n    return canMove;\n};\n// Function to push the rock and move the player to the new position\nconst pushAndMove = (maze, row, col, direction) => {\n\n    const newMaze = maze.map(row => [...row]);\n    const { newRow, newCol } = updatePosition(row, col, direction);\n\n\n    const [nextRow, nextCol] = updatePostionAsArray(newRow, newCol, direction, false);\n\n\n    newMaze[row][col] = symbols.empty;\n    newMaze[newRow][newCol] = symbols.worker;\n    newMaze[nextRow][nextCol] = symbols.rock;\n\n\n    return newMaze;\n};\n\n// Function to handle the player's interaction with a rock\nconst handleRockInteraction = (maze, row, col, direction) => {\n    if (canPushAndMove(maze, row, col, direction)) {\n        // Push the rock and move the player to the new position\n        const newMaze = pushAndMove(maze, row, col, direction);\n        const { newRow, newCol } = updatePosition(row, col, direction);\n        player.row = newRow;\n        player.col = newCol;\n        return newMaze;\n    }\n\n    // If the player can't push the rock, return the original maze without moving the player\n    return maze;\n};\n\nconst crushed = () => {\n    player.isCrushed = true;\n};\n\n\nis_finish = false\n// Function to move the player\nconst movePlayer = (maze, direction) => {\n    let newMaze = maze.map(row => [...row]);\n    const { row, col } = player;\n\n    if (player.isCrushed) {\n        // Player is crushed, no movement allowed\n        return maze;\n    }\n\n        // Check if the new position is under a falling element\n        if (isUnderFallingElement(maze, previousMaze, row, col)) {\n            // If it is, prevent the player from moving horizontally\n            if(direction === 'left' || direction === 'right') {\n                direction = 'none';\n            }\n        }\n        else {\n        }\n\n        if(direction === 'space') {\n            if(player.dynamite > 0)\n            {\n                //check level_state.dynamites if not a dynamite already there\n                let dynamiteAlreadyThere = false;\n                for(let i = 0; i < level_state.dynamites.length; i++)\n                {\n                    if(level_state.dynamites[i].r === row && level_state.dynamites[i].c === col)\n                    {\n                        dynamiteAlreadyThere = true;\n                        break;\n                    }\n                }\n                if(!dynamiteAlreadyThere)\n                {\n                    level_state.dynamites.push({r: row, c: col, time: 10});\n                    updateDynamiteCount(player.dynamite);\n                    player.dynamite--;\n                }\n               \n            }\n            return newMaze;\n        }\n\n    const { newRow, newCol } = updatePosition(row, col, direction);\n\n\n    if (isValidMove(maze, newRow, newCol)) {\n        if (isDiamond(maze, newRow, newCol)) {\n            player.thisLevelDiamonds++;\n            player.totalDiamonds++;\n        }\n        else if (isRock(maze, newRow, newCol)) {\n           return handleRockInteraction(maze, row, col, direction);\n        }\n        else if (isWall(maze, newRow, newCol)) {\n            // Player can not move there\n            return maze;\n        }\n        else if (isWater(maze, newRow, newCol)) {\n            // Player can not move there\n            return maze;\n        }\n        else if (isExit(maze, newRow, newCol)) {\n            // Game restarts\n            is_finish = true;\n        }\n        else if (isDynamite(maze, newRow, newCol)) {\n            return maze;\n        }\n        else if (isBarrier(maze, newRow, newCol)) {\n            return maze;\n        }\n        else if (isMagic(maze, newRow, newCol)) {\n            return maze;\n        }\n\n        newMaze[row][col] = symbols.empty;\n        newMaze[newRow][newCol] = symbols.worker;\n        player.row = newRow;\n        player.col = newCol;\n    }\n\n\n    return newMaze;\n};\n\n\n\n\n\n\n\nconst addWaterToRandomAdjacent = (old_maze, first = false) => {\n    maze = old_maze.map(row => [...row]);\n   \n    let waterAdded = false;\n    if(first)\n    {\n        // if (player.steps === 100) newMaze[player.initialPosition.row][player.initialPosition.col] = symbols.water;\n        maze[player.initialPosition.row][player.initialPosition.col] = symbols.water;\n        return maze;\n    }\n\n    const addWater = (maze, r, c) => {\n        waterAdded = true;\n        maze[r][c] = symbols.water;\n        // Check all positions around the water position for dirt and add them to dirtAdjacentPositions\n        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n        directions.forEach(([dr, dc]) => {\n            if (isDirt(maze, r + dr, c + dc)) {\n                dirtAdjacentPositions.push({ r: r + dr, c: c + dc });\n            }\n        });\n    }\n\n    // Find all water positions and their empty or dirt adjacent positions\n    for (let r = 0; r < maze.length; r++) {\n        for (let c = 0; c < maze[0].length; c++) {\n            if (maze[r][c] === symbols.water) {\n                let bottomR = r + 1;\n                let bottomC = c;\n\n                // Prioritize downward flow\n                if (isEmptyOrPlayer(maze, bottomR, bottomC)) {\n                    if (isPlayer(maze, bottomR, bottomC)) {\n                        crushed();\n                    }\n                    addWater(maze, bottomR, bottomC);\n                    return maze;\n                } \n            }\n        }\n    }\n\n    // Secondary direction checks (right and left) only if water was not added in the downward direction\n    if (!waterAdded) {\n        for (let r = maze.length - 1; r >= 0; r--) {\n            for (let c = maze[0].length - 1; c >= 0; c--) {\n                if (maze[r][c] === symbols.water) {\n                    // Check right, then left\n                    if (isEmptyOrPlayer(maze, r, c + 1)) {\n                        if (isPlayer(maze, r, c + 1)) {\n                            crushed();\n                        }\n                        maze[r][c + 1] = symbols.water;\n                        return maze;\n                    } else if (isEmptyOrPlayer(maze, r, c - 1)) {\n                        if (isPlayer(maze, r, c - 1)) {\n                            crushed();\n                        }\n                        addWater(maze, r, c - 1);\n                        return maze;\n                    }\n                }\n            }\n        }\n    }\n\n    // Third direction checks (up) only if water was not added in the downward direction or secondary direction\n    if (!waterAdded) {\n        for (let r = maze.length - 1; r >= 0; r--) {\n            for (let c = maze[0].length - 1; c >= 0; c--) {\n                if (maze[r][c] === symbols.water) {\n                    // Check up\n                    if (isEmptyOrPlayer(maze, r - 1, c)) {\n                        if (isPlayer(maze, r - 1, c)) {\n                            crushed();\n                        }\n                        addWater(maze, r - 1, c);\n                        return maze;\n                    }\n                }\n            }\n        }\n    }\n\n    if (++stuck >= 10 ) {\n        if(dirtAdjacentPositions.length > 0)\n        {\n            // If stuck for 10 steps, choose a random adjacent position of dirt and turn it into water\n            let pos = dirtAdjacentPositions[Math.floor(Math.random() * dirtAdjacentPositions.length)];       //maze[pos.r][pos.c] = symbols.water;\n            addWater(maze, pos.r, pos.c);\n            stuck = 0;\n         }\n        else {\n        }\n    }\n    else\n    {\n       // console.log(\"stuck\", stuck);\n    }\n  \n    return maze;\n};\n\nconst createLevel = (currentLevel = level_state.currentLevel) => {\n    let maze;\n    let exitIsReachable;\n\n\n    Object.assign(level_state, level_state_backup);\n\n\n    // Set current level\n    level_state.currentLevel = currentLevel;\n    let calclevel = currentLevel - 1;\n    let initial_start_the_water = level_state.start_the_water;\n\n    // Update start_the_water and water_every_x_round\n    level_state.start_the_water = Math.max(initial_start_the_water - calclevel, 20);\n    if (currentLevel > 10 && currentLevel <= 20) {\n        level_state.water_every_x_round = 2;\n    } else if (currentLevel > 20) {\n        level_state.water_every_x_round = 1;\n    }\n\n    // Update percentages\n    let diamondPercentage = Math.min(10 + calclevel, 20);\n    let rockPercentage = Math.min(10 + (calclevel * 1), 25);\n    let emptyPercentage = Math.min(10 + (calclevel * 0.9), 25);\n    let wallPercentage = Math.min(10 + (calclevel * 1), 25);\n\n    // Update diamondPercentageThreshold based on current level (max 50%)\n    if (level_state.currentLevel <= 50) {\n        level_state.diamondPercentageThreshold = level_state.diamondPercentageThreshold  + (0.01 * calclevel);\n    } else {\n        level_state.diamondPercentageThreshold = 0.50;\n    }\n\n\n    const totalPercentage = diamondPercentage + rockPercentage + emptyPercentage + wallPercentage;\n\n    if (totalPercentage > 100) {\n        const excessPercentage = totalPercentage - 100;\n        rockPercentage -= excessPercentage / 3;\n        emptyPercentage -= excessPercentage / 3;\n        wallPercentage -= excessPercentage / 3;\n    }\n\n    const { cols, rows } = calculateRowsCols();\n\n    while (!exitIsReachable) {\n        maze = mazeMakerByPercentages(cols, rows, diamondPercentage, rockPercentage, emptyPercentage, wallPercentage);\n        exitIsReachable = canReachExit(maze);\n    }\n\n    level_state.dynamites = [];\n\n    return { maze, nextLevel: currentLevel + 1 };\n};\n\n\nconst finish = (levelUp) => levelUp ? startGame(++level_state.currentLevel) : startGame(level_state.currentLevel);\n\nconst step = (maze) => {\n    let newMaze = maze.map(row => [...row]);\n    player.steps++;\n\n    if (player.steps === level_state.start_the_water ) {newMaze = addWaterToRandomAdjacent(newMaze, true);}  \n    else if (player.steps > level_state.start_the_water ) \n    {\n        if(player.steps % level_state.water_every_x_round === 0)\n        {\n            newMaze = addWaterToRandomAdjacent(newMaze);\n        }\n    }\n    \n    if(isUnderFallingElement(newMaze, previousMaze, player.row, player.col)) crushed();\n    newMaze = applySlipOrGravity(newMaze);\n    if (player.action) newMaze = movePlayer(newMaze, player.action);\n\n    // Iterate over dynamites and set them where they belong\n    newMaze = removeExplosion(newMaze);\n    level_state.dynamites.forEach(dynamite => {\n        if(dynamite.time > 0)  {\n            newMaze = setDynamite(newMaze, dynamite.r, dynamite.c);\n            dynamite.time--;\n        } else {\n            newMaze = explodeDynamite(newMaze, dynamite.r, dynamite.c);\n            // Remove exploded dynamites from the array\n            level_state.dynamites = level_state.dynamites.filter(d => d.time > 0);\n        }\n    });\n\n    // Change magic to dirt only if barriers have been changed to magic\n    if (level_state.barriersChangedToMagic) {\n        newMaze = changeMagicToDirt(newMaze);\n    }\n\n    // Change barriers to magic only if the level diamond ratio is reached and barriers haven't been changed to magic yet\n    if (!level_state.barriersChangedToMagic && getDiamondRatio(player.thisLevelDiamonds, totalDiamonds) >= (level_state.diamondPercentageThreshold)) {\n        newMaze = changeBarrierToMagic(newMaze);\n        level_state.barriersChangedToMagic = true;\n    } \n\n\n\n    player.action = null;\n    previousMaze = maze;\n    return newMaze;\n};\n\nconst removeExplosion = (maze) => {\n    for (let row = 0; row < maze.length; row++) {\n        for (let col = 0; col < maze[row].length; col++) {\n            if (isExplosion(maze, row, col)) {\n                maze = setEmpty(maze, row, col);\n            }\n        }\n    }\n    return maze;\n};\n\n\n\nfunction explodeDynamite(maze, r, c) {\n    for (let dr = -1; dr <= 1; dr++) {\n        for (let dc = -1; dc <= 1; dc++) {\n            const row = r + dr;\n            const col = c + dc;\n            if (row >= 0 && row < maze.length && col >= 0 && col < maze[0].length) {\n                if (isPlayer(maze, row, col)) {\n                    crushed();\n                } else {\n                    maze = setExplosion(maze, row, col);\n                }\n            }\n        }\n    }\n    return maze;\n}\n\nconst clearPreviousGameLoop = (gameLoop) => gameLoop && clearInterval(gameLoop);\n\n// Function to reset the player's state\nconst resetPlayerState = (player) => {\n    const totalDiamonds = player.totalDiamonds;\n    player = {...backupPlayer};\n    player.totalDiamonds = totalDiamonds;\n    return player;\n};\n\n\n\n// Function to start a new game loop\nconst startNewGameLoop = (maze, mazeElement) => {\n    return setInterval(() => {\n        maze = step(maze);\n        displayMaze(maze);\n        resizeMaze(maze, mazeElement);\n        \n        \n        if (is_finish) {\n            finish(true);\n        }\n    }, 250);\n};\n\nconst startGame = (level = 1) => {\n    is_finish = false;\n    dirtAdjacentPositions = [];\n    clearPreviousGameLoop(gameLoop);\n    player = resetPlayerState(player);\n    resetDynamiteCount();\n    const { maze, nextLevel } = createLevel(level);\n    currentMaze = maze;\n    previousMaze = maze;\n    totalDiamonds = maze.reduce((count, row) => count + row.filter(cell => cell === symbols.diamond).length, 0);\n    gameLoop = startNewGameLoop(currentMaze, mazeElement);\n};\n\nstartGame();\n\nconst addPlayerAction = (key) => {\n    if(player.action != 'space')\n    {\n        player.action = key;\n    }\n}\n\n// Listen for key presses and set the player's action\nwindow.addEventListener('keydown', (event) => {\n    //player.action = keyActionMap[event.key];\n    addPlayerAction(keyActionMap[event.key]);\n});\nlet joystickCenterX = null;\nlet joystickCenterY = null;\nconst moveThreshold = 20;  // Set the movement threshold to 20px\nconst getTouchCoordinates = (event) => ({\n    touchX: event.touches[0].clientX,\n    touchY: event.touches[0].clientY\n});\n\nconst updateJoystickCenter = (touchX, touchY) => {\n    joystickCenterX = touchX;\n    joystickCenterY = touchY;\n}\n\nconst handleJoystickMovement = (dx, dy, touchX, touchY) => {\n    if (Math.abs(dx) > Math.abs(dy)) {\n        // Horizontal movement\n        if (Math.abs(dx) > moveThreshold) {\n            if (dx > 0) {\n                addPlayerAction('right');\n            } else {\n                addPlayerAction('left');\n            }\n            updateJoystickCenter(touchX, touchY);\n        }\n    } else {\n        // Vertical movement\n        if (Math.abs(dy) > moveThreshold) {\n            if (dy > 0) {\n                addPlayerAction('down');\n            } else {\n                addPlayerAction('up');\n            }\n            updateJoystickCenter(touchX, touchY);\n        }\n    }\n}\n\nconst handleTouchMove = (event) => {\n    event.preventDefault();\n    if (joystickCenterX === null && joystickCenterY === null) {\n        updateJoystickCenter(event.touches[0].clientX, event.touches[0].clientY);\n    }\n\n    let { touchX, touchY } = getTouchCoordinates(event);\n    let dx = touchX - joystickCenterX;\n    let dy = touchY - joystickCenterY;\n\n    handleJoystickMovement(dx, dy, touchX, touchY);\n}\n\n\nconst resetJoystickCenter = () => {\n    joystickCenterX = null;\n    joystickCenterY = null;\n}\n\nconst handleTouchStart = (event) => {\n    event.preventDefault();\n    resetJoystickCenter();\n}\n\n\nlet lastTap = 0;\nlet lastTapX = null;\nlet lastTapY = null;\n\nconst getTapLength = (currentTime, lastTap) => currentTime - lastTap;\n\nconst getTapCoordinates = (event) => ({\n    tapX: event.changedTouches[0].clientX,\n    tapY: event.changedTouches[0].clientY\n});\n\nconst calculateDistance = (x1, y1, x2, y2) => Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n\nconst isDoubleTap = (tapLength, dx, dy) => tapLength < 500 && tapLength > 0 && dx <= 30 && dy <= 30;\n\nconst getCurrentTime = () => new Date().getTime();\n\nconst updateLastTap = (currentTime, tapX, tapY) => {\n    lastTap = currentTime;\n    lastTapX = tapX;\n    lastTapY = tapY;\n}\n\nconst handleTouchEnd = (event) => {\n    event.preventDefault();\n    let currentTime = getCurrentTime();\n    let { tapX, tapY } = getTapCoordinates(event);\n    let tapLength = getTapLength(currentTime, lastTap);\n    let dx = tapX - lastTapX;\n    let dy = tapY - lastTapY;\n    let distance = calculateDistance(dx, dy);\n\n    if (isDoubleTap(tapLength, distance)) {\n       // addPlayerAction('space');\n    }\n\n    updateLastTap(currentTime, tapX, tapY);\n    resetJoystickCenter();\n}\n\n\nmazeElement.addEventListener('touchstart', handleTouchStart, false);\nmazeElement.addEventListener('touchend', handleTouchEnd);\nmazeElement.addEventListener('touchmove', handleTouchMove, false);\n\n\ndocument.getElementById('restart').addEventListener('click', function() {\n    event.preventDefault();\n    finish(false);\n});\n\ndocument.getElementById('dynamite-count').addEventListener('touchend', function(event) {\n    event.preventDefault();\n    addPlayerAction('space');\n});\n\nwindow.onload = function() {\n    if (window.location.hostname.includes('franzai')) {\n        try {\n            history.replaceState(null, null, \"https://interdimensional-chimney.franzai.com/\");\n        } catch (error) {\n            console.error(\"Failed to replace state: \", error);\n        }\n    }\n};\n\nThis is the end of /interdimensional-chimney/game.js\n\n"
    ],
    [
      "/interdimensional-chimney/index.html",
      "This is my current /interdimensional-chimney/index.html on 2024-11-13 11:54:28\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Interdimensional Chimney - üéÑüéÖüéÅ-Game by Franz Enzenhofer</title> \n    <link rel=\"nostylesheet\" href=\"./styles.css\">\n    <link rel=\"canonical\" href=\"https://interdimensional-chimney.franzai.com/\">\n    <meta property=\"og:image\" content=\"https://interdimensional-chimney.franzai.com/game2.jpeg\">\n    <meta property=\"og:url\" content=\"https://interdimensional-chimney.franzai.com/\">\n    <meta property=\"og:title\" content=\"Interdimensional Chimney - üéÑüéÖüéÅ-Game by Franz Enzenhofer\">\n<meta property=\"og:description\" content=\"Join Santa in a festive adventure through the mystical chimneys of the world.\">\n<meta property=\"og:type\" content=\"website\">\n<meta property=\"og:site_name\" content=\"Interdimensional Chimney\">\n\n    <style>\n        /* Additional CSS for mobile-first design and Christmas theme */\n        body, html {\n    margin: 0;\n    padding: 0;\n    height: 100vh; /* 100% of the viewport's height */\n    display: flex; /* Use flexbox for layout */\n    flex-direction: column; /* Stack elements vertically */\n    justify-content: space-between; /* Distribute space evenly between elements */\n    background-color: #008000; /* Standard green */\n    color: #fff; /* White text for better contrast */\n    font-family: 'Menlo', monospace; /* Consistent font */\n    text-align: center; /* Center align elements */\n    font-size:16px;\n}\n\nmain {\n    flex: 1 0 auto; /* Flex item that grows and shrinks, but doesn't shrink below its content's size */\n    padding: 5px;\n    overflow: auto; /* Allows content to scroll if it exceeds its container's size */\n}\n        .button {\n            background-color: #c0392b; /* Christmas red */\n            color: #fff;\n            padding: 10px 20px;\n            border: none;\n            border-radius: 50px; /* Make the button rounder */\n            cursor: pointer;\n            font-size: 16px;\n            margin: 25px;\n            transition: all 0.3s ease; /* Smooth transition for all changes */\n            box-shadow: 0px 8px 15px rgba(0, 0, 0, 0.1); /* Subtle shadow for 3D effect */\n            text-shadow: none; /* Remove text shadow for cleaner look */\n        }\n\n        .button:hover {\n            background-color: #e74c3c; /* Lighter red when hovered */\n            box-shadow: 0px 15px 20px rgba(0, 0, 0, 0.2); /* Larger shadow when hovered */\n            transform: translateY(-3px); /* Slightly raise the button when hovered */\n        }\n\n        .button:active {\n            box-shadow: 0 5px #666; /* Reduce shadow when button is clicked */\n            transform: translateY(2px); /* Move button down when clicked */\n        }\n\n        @media (min-width: 768px) {\n            /* Adjustments for larger screens */\n            .button {\n                font-size: 22px;\n            }\n        }\n        h1 {\n            font-size:150%;\n        }\n        a {\n    color: #ffffff; /* White text */\n    text-decoration: none; /* No underline */\n}\n    </style>\n</head>\n<body>\n    <main>\n        <h1>üéÖ Interdimensional Chimney üè†</h1>\n            Collect at least 20% of all üéÅ, do not get hit by falling-üåü and droping üéÅ, and watch out for cold ‚ùÑÔ∏è.\n            <br><br>Use üí£ to clear paths. Reach the üéÑ to deliver joy!\n        </p>\n        <a href=\"game.html\" class=\"button\">Start Game üéÆ</a>\n        <p>[Space] or tab the 3-üí£üí£üí£ for üí£.</p>\n        <strong>Mobile:</strong> Move üëÜ to navigate<br>(Like with a üïπÔ∏è.)</p>\n        <p>üñ•Ô∏è <strong>Desktop:</strong> Use arrow keys to move.\n        <p>üîÑ for restart.</p>\n        <footer>\n            <small>üõ†Ô∏è Crafted by <u><a href=\"https://www.fullstackoptimization.com/p/team\">Franz Enzenhofer</a></u> üéâ</small>\n        </footer>\n    </main>\n</body>\n</html>\n\n\nThis is the end of /interdimensional-chimney/index.html\n\n"
    ],
    [
      "/interdimensional-chimney/LICENSE",
      "This is my current /interdimensional-chimney/LICENSE on 2024-11-13 11:54:28\n\nMIT License\n\nCopyright (c) 2023 Franz Enzenhofer\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n\nThis is the end of /interdimensional-chimney/LICENSE\n\n"
    ],
    [
      "/interdimensional-chimney/styles.css",
      "This is my current /interdimensional-chimney/styles.css on 2024-11-13 11:54:28\n\nbody, html {\n    margin: 0;\n    padding: 0;\n    height: 100%;\n    background-color: #B22222; /* Christmas Red background */\n    overflow: hidden;\n}\n\n.info {\n    font-size: 20px;\n    font-family: 'Menlo', 'Monaco', 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    height: 40px;\n    padding: 0 10px;\n    background-color: #B22222; /* Christmas Red background */\n    color: #ffffff; /* White text */\n    white-space: nowrap;\n    overflow: hidden;\n}\n\n.grayed-out {\n  filter: grayscale(100%) brightness(20%);\n}\n.info > div {\n  flex: 1 0 auto;\n  text-overflow: ellipsis;\n  overflow: hidden;\n}\n\n.info .diamonds {\n  text-align: right;\n}\n\n.maze {\n  position: absolute;\n  top: 40px;\n  bottom: 0;\n  width: 100%;\n  overflow-y: visible;\n  overflow-x: visible;\n}\n\ntable {\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n\ntd {\n  border: 0;\n  margin: 0;\n  padding: 0;\n  line-height: 1;\n  overflow: visible;\n  text-align: center;\n  vertical-align: middle;\n}\n\ntr {\n  border: 0;\n  margin: 0;\n  padding: 0;\n  line-height: 1;\n  overflow: visible;\n  text-align: center;\n  vertical-align: middle;\n}\n\n.üë∑‚Äç‚ôÇÔ∏è {\n  overflow: visible;\n}\n\n.üòµ {\n  overflow: visible;\n}\n\n.üï∏Ô∏è{\n  filter: brightness(220%);\n}\n\n.üéÅ {\n  animation: pulse 2s;\n  animation-iteration-count: 3;\n}\n\n@keyframes pulse {\n  0% {\n    filter: brightness(100%);\n  }\n  50% {\n    filter: brightness(120%);\n  }\n  100% {\n    filter: brightness(100%);\n  }\n}\n\n.greentext {\n  color: #00ff00;\n}\n\n.üü©, .üéÅ, .üåü, .‚¨õÔ∏è, .üß±, .üéÑ, .üéÖ, .üëª, .‚ùÑÔ∏è, .üí£, .üéÜ, .üßù, .‚ú®, .üßä, .‚õÑÔ∏è, .üéâ, .üí• {\n  background-color: #000; /* Black background */\n}\n\n\n.maze td {\n            width: 24px;\n            height: 24px;\n        }\n\n.üï≥Ô∏è {\n  box-shadow: inset 0 0 10px #fff;\n}\n\na {\n    color: #ffffff; /* White text */\n    text-decoration: none; /* No underline */\n}\n\nThis is the end of /interdimensional-chimney/styles.css\n\n"
    ],
    [
      "/interdimensional-chimney/CNAME",
      "This is my current /interdimensional-chimney/CNAME on 2024-11-13 11:54:28\n\ninterdimensional-chimney.franzai.com\n\nThis is the end of /interdimensional-chimney/CNAME\n\n"
    ],
    [
      "/interdimensional-chimney/game.html",
      "This is my current /interdimensional-chimney/game.html on 2024-11-13 11:54:28\n\n<!DOCTYPE html> \n<html lang=\"en\"> \n<head> \n  <meta charset=\"UTF-8\"> \n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no\"> \n  <title>Interdimensional Chimney - üéÑüéÖüéÅ-Game by Franz Enzenhofer</title> \n  <link rel=\"stylesheet\" href=\"./styles.css\">\n  <link rel=\"canonical\" href=\"https://interdimensional-chimney.franzai.com/\">\n  <meta property=\"og:image\" content=\"https://interdimensional-chimney.franzai.com/game2.jpeg\">\n  <meta property=\"og:url\" content=\"https://interdimensional-chimney.franzai.com/\">\n  <meta property=\"og:title\" content=\"Interdimensional Chimney - üéÑüéÖüéÅ-Game by Franz Enzenhofer\">\n<meta property=\"og:description\" content=\"Join Santa in a festive adventure through the mystical chimneys of the world.\">\n<meta property=\"og:type\" content=\"website\">\n<meta property=\"og:site_name\" content=\"Interdimensional Chimney\">\n</head>\n<body> \n  <header class=\"info\"> \n      <div class=\"level-restart\">\n        <a href=\"./index.html\">\n          <span id=\"level\">üè†1</span>\n        </a>        <span id=\"restart\">üîÑ</span>\n      </div>\n      <center id=\"dynamite-count\">\n        <span class=\"dc\" id=\"dynamite-1\">üí£</span>\n        <span class=\"dc\" id=\"dynamite-2\">üí£</span>\n        <span class=\"dc\" id=\"dynamite-3\">üí£</span>\n      </center>\n      <div class=\"diamonds\">\n        <span id=\"diamonds\">&nbsp;&nbsp;0%üéÅ</span>\n      </div>\n  </header>\n\n  <center><div id=\"maze\" class=\"maze\"></div></center> \n  <script src=\"./game.js?ddevfdgfgskhjkhddfsd\"></script> \n</body> \n\nThis is the end of /interdimensional-chimney/game.html\n\n"
    ],
    [
      "note:1731499135226",
      "----\n\nTo build a responsive, emoji-based HTML5 game with no dependencies that works seamlessly on both mobile and desktop, you‚Äôll want to follow a set of best practices focused on responsive design, touch-and-keyboard input handling, dynamic scaling, and performance optimization. Here‚Äôs a detailed guide on the general approach:  ---  ## 1. Concept and Design Planning  **Goal**: Design a simple and accessible game using emojis as visual elements. Emojis are lightweight, widely supported, and offer a consistent experience across devices.  - **Platform Accessibility**: Ensure the game works across mobile and desktop devices. This includes touch and keyboard support, responsive layout adjustments, and optimized display for various screen sizes. - **Responsiveness**: Design the layout so it scales proportionally to fit any screen size without relying on browser zooming or page scaling. - **Single Page Application**: Use a single HTML file or minimal HTML files to keep the game lightweight and responsive. - **No External Dependencies**: Avoid external libraries (e.g., jQuery) to ensure the game is self-contained, loads quickly, and has minimal performance overhead.  ---  ## 2. Set Up the Basic HTML Structure  Create a minimal HTML structure with semantic elements for a clean and responsive layout.  ### Basic HTML Layout  - **Use `meta` tags** to control scaling and make the game responsive:   ```html   <!DOCTYPE html>   <html lang=\"en\">   <head>     <meta charset=\"UTF-8\">     <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no\">     <title>Emoji Game</title>     <style>       /* Basic styling here */     </style>   </head>   <body>     <div id=\"game\"></div>     <script src=\"game.js\"></script>   </body>   </html>   ```  - **Viewport meta tag** ensures the game fills the screen without allowing users to zoom, which keeps the game‚Äôs design fixed. - **Flexible layout container** (`div#game`) will dynamically scale and hold the game's grid.  ---  ## 3. Responsive Design and Dynamic Sizing with CSS and JavaScript  Design the game layout to adapt to different screen sizes by calculating the optimal number of rows and columns based on the screen‚Äôs width and height.  ### Dynamic Sizing and Font Adjustment  - **CSS Styling**: Apply basic, mobile-first styling and override it with media queries for larger screens.   ```css   body, html {     margin: 0;     padding: 0;     overflow: hidden;     display: flex;     justify-content: center;     align-items: center;     height: 100vh;     font-family: 'Arial', sans-serif;   }    #game {     display: grid;     gap: 2px;     font-size: calc(100vw / 20); /* Adjust font size based on viewport */   }   ```  - **JavaScript for Dynamic Layout**: Use JavaScript to determine the grid size and cell dimensions based on the screen size. Calculate the number of rows and columns dynamically:   ```javascript   function calculateGridSize() {     const gameElement = document.getElementById('game');     const screenWidth = window.innerWidth;     const screenHeight = window.innerHeight;     const cellSize = Math.min(screenWidth, screenHeight) / 20;     gameElement.style.fontSize = `${cellSize}px`;      // Calculate rows and columns for the grid     const rows = Math.floor(screenHeight / cellSize);     const cols = Math.floor(screenWidth / cellSize);     createGameGrid(rows, cols);   }   ```  - **Resize Event Listener**: Add an event listener to recalculate the grid if the screen is resized, ensuring responsiveness.   ```javascript   window.addEventListener('resize', calculateGridSize);   ```  ---  ## 4. Emoji-Based Game Elements  Use emojis to represent game elements (player, obstacles, rewards) to avoid the need for graphic assets.  ### Define Emoji Elements in JavaScript  - **Emoji Map**: Create an object to store emojis for each game element.   ```javascript   const symbols = {     player: 'üïπÔ∏è',     treasure: 'üíé',     wall: 'üß±',     empty: '‚¨ú'   };   ```  - **Game Grid Creation**: Initialize the grid as a 2D array, filling it with `empty` emojis by default and adding other elements like `player`, `treasure`, or `wall` as needed.   ```javascript   function createGameGrid(rows, cols) {     const grid = Array.from({ length: rows }, () => Array(cols).fill(symbols.empty));     // Place other elements (e.g., player, treasure)     grid[0][0] = symbols.player;     displayGrid(grid);   }   ```  ---  ## 5. Input Handling for Both Mobile and Desktop  Support both keyboard input (for desktop) and touch input (for mobile). This ensures the game is playable across all devices without external dependencies.  ### Keyboard Controls  - **Arrow Key Handling**: Use `keydown` events for desktop keyboard input.   ```javascript   window.addEventListener('keydown', (event) => {     const direction = { ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right' }[event.key];     if (direction) movePlayer(direction);   });   ```  ### Touch Controls for Mobile  - **Touch Input for Swiping**: Use touchstart and touchmove events to detect swipes.   ```javascript   let touchStartX = 0, touchStartY = 0;    gameElement.addEventListener('touchstart', (e) => {     const touch = e.touches[0];     touchStartX = touch.clientX;     touchStartY = touch.clientY;   });    gameElement.addEventListener('touchmove', (e) => {     const touch = e.touches[0];     const dx = touch.clientX - touchStartX;     const dy = touch.clientY - touchStartY;      if (Math.abs(dx) > Math.abs(dy)) {       movePlayer(dx > 0 ? 'right' : 'left');     } else {       movePlayer(dy > 0 ? 'down' : 'up');     }   });   ```  ---  ## 6. Game Loop and State Management  Set up a simple game loop to update the game state (player position, score, etc.) and re-render the grid regularly.  ### Game State Object  Define a game state object to store information such as player position, score, and current grid layout. ```javascript const gameState = {   playerPosition: { row: 0, col: 0 },   score: 0,   grid: [] }; ```  ### Game Loop with `setInterval`  Use a game loop to handle periodic updates (such as movement and animation) without relying on any external libraries. ```javascript function startGameLoop() {   setInterval(() => {     updateGameState();     renderGame();   }, 100); // Adjust interval as needed } ```  ---  ## 7. Rendering and Display  Render the grid dynamically, updating only the cells that change to minimize performance overhead.  ### Grid Rendering  - **Initial Display**: Render the entire grid initially by generating HTML elements for each cell. - **Efficient Updates**: For each frame, only update cells that have changed.   ```javascript   function renderGame() {     const gameElement = document.getElementById('game');     gameElement.innerHTML = gameState.grid.map(row => row.map(cell => `<span>${cell}</span>`).join('')).join('<br>');   }   ```  ### Responsiveness for Different Devices  Keep text size and layout proportionate to the screen using CSS and JavaScript to calculate an appropriate font size.  ---  ## 8. Handling Scaling and Performance  Keep the game performant by minimizing DOM manipulation and using efficient methods to handle game logic.  ### Performance Tips  - **Avoid frequent DOM updates**: Update only parts of the game that have changed. - **Use requestAnimationFrame for Animations**: For smooth animations, use `requestAnimationFrame`. - **Optimize Grid Layout**: Use CSS Grid or Flexbox for layout flexibility. - **Event Throttling**: Limit the rate of input handling to prevent performance issues on mobile.  ---  ## 9. CSS Styles for Mobile-First Design  Keep CSS simple and mobile-first. Avoid complex styling and animations that can slow down the game on mobile devices.  ### Basic CSS Example  ```css #game {   display: grid;   grid-template-columns: repeat(auto-fit, minmax(24px, 1fr));   gap: 2px; }  span {   display: inline-block;   width: 100%;   text-align: center; } ```  ---  ## 10. Testing and Final Adjustments  ### Cross-Device Testing  Test the game on various devices and screen orientations to ensure it scales properly and controls are responsive. Use Chrome DevTools or a similar tool to emulate different devices.  ### Accessibility Considerations  Ensure elements have sufficient color contrast and are readable. You can use ARIA labels if text-to-speech support is required.  ---  ## Summary  By following this framework, you can create a responsive, emoji-based HTML5 game that works well across devices and is easily maintainable. This setup prioritizes simplicity, responsiveness, and performance, making it a robust choice for developing lightweight, interactive games.\n\n----\n\n"
    ]
  ],
  "selectionOrder": [
    "note:1731499135226",
    "/interdimensional-chimney/game.js",
    "/interdimensional-chimney/index.html",
    "/interdimensional-chimney/LICENSE",
    "/interdimensional-chimney/styles.css",
    "/interdimensional-chimney/CNAME",
    "/interdimensional-chimney/game.html"
  ]
}